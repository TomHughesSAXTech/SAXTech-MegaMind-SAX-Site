<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAX Document Portal</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
            font-size: 14px;
        }

        .header {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: white;
            padding: 24px 40px;
            border-bottom: 3px solid #3b82f6;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .company-logo {
            width: 48px;
            height: 48px;
            background: #3b82f6;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 20px;
            color: white;
        }

        .company-name {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .portal-title {
            font-size: 14px;
            color: #94a3b8;
            font-weight: 400;
            margin-top: 2px;
        }

        .header-meta {
            text-align: right;
            font-size: 12px;
            color: #94a3b8;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 40px;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 32px;
            min-height: calc(100vh - 120px);
        }

        .sidebar {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            height: fit-content;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }

        .sidebar-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 12px 12px 0 0;
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 4px;
        }

        .sidebar-subtitle {
            font-size: 12px;
            color: #64748b;
        }

        .form-section {
            padding: 24px;
        }

        .notice-banner {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .notice-header {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 8px;
        }

        .notice-icon {
            color: #d97706;
            font-size: 16px;
            margin-top: 1px;
        }

        .notice-title {
            font-weight: 600;
            color: #92400e;
            font-size: 13px;
        }

        .notice-text {
            color: #92400e;
            font-size: 12px;
            line-height: 1.5;
            margin-left: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #374151;
            font-size: 13px;
        }

        .required {
            color: #dc2626;
        }

        .form-select, .form-input, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease;
            background: white;
            color: #374151;
        }

        .form-select:focus, .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .file-upload-section {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 24px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-upload-section:hover {
            border-color: #3b82f6;
            background: #f8fafc;
        }

        .file-upload-section.dragover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            background: #f1f5f9;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px;
            color: #64748b;
            font-size: 20px;
        }

        .upload-text {
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
        }

        .upload-subtext {
            color: #64748b;
            font-size: 12px;
        }

        .file-input {
            display: none;
        }

        .selected-file {
            margin-top: 12px;
            padding: 12px;
            background: #f0fdf4;
            border: 1px solid #16a34a;
            border-radius: 6px;
            display: none;
            text-align: left;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #15803d;
            font-size: 12px;
            font-weight: 500;
        }

        .btn-primary {
            width: 100%;
            background: #3b82f6;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .main-content {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }

        .content-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 12px 12px 0 0;
        }

        .content-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 4px;
        }

        .content-subtitle {
            font-size: 13px;
            color: #64748b;
        }

        .explorer-container {
            padding: 24px;
            display: none;
        }

        .explorer-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 16px;
        }

        .search-container {
            flex: 1;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            font-size: 14px;
        }

        .stats-panel {
            display: flex;
            gap: 24px;
            align-items: center;
            font-size: 12px;
            color: #64748b;
        }

        .folder-grid {
            display: grid;
            gap: 16px;
        }

        .folder-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }

        .folder-header {
            background: #f8fafc;
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s ease;
        }

        .folder-header:hover {
            background: #f1f5f9;
        }

        .folder-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .folder-icon {
            color: #64748b;
            font-size: 16px;
            transition: transform 0.2s ease;
        }

        .folder-card.expanded .folder-icon {
            transform: rotate(90deg);
        }

        .folder-name {
            font-weight: 500;
            color: #374151;
            font-size: 14px;
        }

        .folder-count {
            font-size: 12px;
            color: #64748b;
            background: #f1f5f9;
            padding: 2px 8px;
            border-radius: 12px;
        }

        .folder-content {
            display: none;
            padding: 16px;
        }

        .folder-card.expanded .folder-content {
            display: block;
        }

        .document-list {
            display: grid;
            gap: 12px;
        }

        .document-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            align-items: flex-start;
            transition: all 0.2s ease;
            background: #fafafa;
        }

        .document-item:hover {
            border-color: #3b82f6;
            background: #f8fafc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .doc-type-icon {
            width: 32px;
            height: 32px;
            background: #3b82f6;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: 600;
        }

        .pdf { background: #dc2626; }
        .docx { background: #2563eb; }
        .xlsx { background: #059669; }
        .txt { background: #7c3aed; }
        
        .chunked-badge {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background: #f59e0b;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            z-index: 2;
        }

        .document-info {
            min-width: 0;
            flex: 1;
        }

        .document-title {
            font-weight: 600;
            color: #1e293b;
            font-size: 14px;
            margin-bottom: 6px;
            line-height: 1.5;
            display: block;
            overflow: visible;
            word-break: normal;
            word-wrap: normal;
            white-space: normal;
        }

        .document-meta {
            display: flex;
            gap: 16px;
            font-size: 11px;
            color: #64748b;
        }

        .document-description {
            font-size: 11px;
            color: #64748b;
            margin-top: 4px;
            line-height: 1.4;
        }

        .document-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 6px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            color: #374151;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .btn-preview:hover {
            background: #eff6ff;
        }

        .btn-download:hover {
            background: #f0fdf4;
            border-color: #059669;
            color: #059669;
        }

        .hidden {
            display: none;
        }
        
        /* Global override to prevent title truncation */
        .document-title,
        .document-item .document-title,
        .folder-card .document-title {
            white-space: normal !important;
            text-overflow: unset !important;
            display: block !important;
            overflow: visible !important;
            line-height: 1.5 !important;
            word-break: break-word !important;
            word-wrap: break-word !important;
            max-width: none !important;
        }

        .existing-sops {
            margin-top: 16px;
        }

        .sop-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: #fafafa;
        }

        .sop-item {
            padding: 10px 12px;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .sop-item:hover {
            background: #f8fafc;
        }

        .sop-item.selected {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .sop-item:last-child {
            border-bottom: none;
        }

        .additional-info {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 12px;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            transition: width 0.3s ease;
        }

        .success-message {
            background: #f0fdf4;
            border: 1px solid #16a34a;
            color: #15803d;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            display: none;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
        }

        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: #64748b;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            background: #f1f5f9;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 24px;
            color: #94a3b8;
        }

        .empty-title {
            font-weight: 500;
            margin-bottom: 8px;
            color: #374151;
        }

        .empty-text {
            font-size: 13px;
            line-height: 1.5;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header {
                padding: 16px 20px;
            }
            
            .explorer-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Preview Modal Styles */
        .preview-modal.active {
            display: flex !important;
        }
        
        .preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <script src="js/multipart-upload.js"></script>
</head>
<body>
    <a href="/" class="back-to-chat" style="position: fixed; top: 20px; left: 20px; background: linear-gradient(135deg, #FFD700, #FFA500); color: #1a1a1a; padding: 10px 20px; border-radius: 25px; text-decoration: none; font-weight: 600; font-size: 14px; transition: all 0.3s ease; z-index: 1000; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">‚Üê Back to MegaMind</a>
    
    <!-- Admin Console Button -->
    <button onclick="openAdminConsole()" style="
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #DC2626, #B91C1C);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        border: 2px solid rgba(255,255,255,0.2);
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
    ">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"></path>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
        Admin Console
    </button>
    
    <header class="header">
        <div class="header-content">
            <div class="logo-section">
                <div class="company-logo">SAX</div>
                <div>
                    <div class="company-name">SAX Technology Advisors</div>
                    <div class="portal-title">Document Management Portal</div>
                </div>
            </div>
            <div class="header-meta" style="display: flex; gap: 24px; align-items: center; width: 100%; justify-content: flex-end;">
                <!-- Simple blob storage stats -->
                <div style="display: flex; gap: 16px; align-items: center; padding: 12px 16px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px;">
                    <div style="text-align: center;">
                        <div style="font-size: 18px; font-weight: bold; color: #FFD700;" id="blobDocCount">0</div>
                        <div style="font-size: 10px; text-transform: uppercase; opacity: 0.8;">Blob Files</div>
                    </div>
                    <div style="text-align: center; border-left: 1px solid rgba(255,255,255,0.2); padding-left: 16px;">
                        <div style="font-size: 18px; font-weight: bold; color: #FFD700;" id="blobLastUpdate">--</div>
                        <div style="font-size: 10px; text-transform: uppercase; opacity: 0.8;">Last Upload</div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Document Upload</div>
                <div class="sidebar-subtitle">Standard Operating Procedures</div>
            </div>
            
            <div class="form-section">
                <div class="notice-banner">
                    <div class="notice-header">
                        <span class="notice-icon">‚ö†</span>
                        <span class="notice-title">COMPLIANCE NOTICE</span>
                    </div>
                    <div class="notice-text">
                        This portal is restricted to internal SAX documentation. Third-party materials require IT department approval prior to upload. Ensure compliance with data retention policies.
                    </div>
                </div>

                <form id="sopUploadForm">
                    <div class="form-group">
                        <label class="form-label" for="department">
                            Department <span class="required">*</span>
                        </label>
                        <select class="form-select" id="department" required>
                            <option value="">Select Department</option>
                            <option value="A&A">Audit & Advisory</option>
                            <option value="Finance">Finance</option>
                            <option value="HR">Human Resources</option>
                            <option value="Leadership">Leadership</option>
                            <option value="Marketing/Business Development">Marketing & Business Development</option>
                            <option value="Operations">Operations</option>
                            <option value="Shared Services">Shared Services</option>
                            <option value="Tax">Tax Services</option>
                            <option value="Transaction Advisory">Transaction Advisory</option>
                            <option value="Wealth Management">Wealth Management</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="sopType">
                            Document Type <span class="required">*</span>
                        </label>
                        <select class="form-select" id="sopType" required>
                            <option value="">Select Type</option>
                            <option value="Process Documentation">Process Documentation</option>
                            <option value="Policy Guidelines">Policy Guidelines</option>
                            <option value="Technical Procedures">Technical Procedures</option>
                            <option value="Compliance Procedures">Compliance Procedures</option>
                            <option value="Training Materials">Training Materials</option>
                            <option value="Quality Standards">Quality Standards</option>
                            <option value="Emergency Procedures">Emergency Procedures</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="updateType">
                            Action Type <span class="required">*</span>
                        </label>
                        <select class="form-select" id="updateType" required>
                            <option value="">Select Action</option>
                            <option value="new">New Document</option>
                            <option value="update">Update Existing</option>
                        </select>
                    </div>

                    <div id="existingSOPs" class="form-group existing-sops hidden">
                        <label class="form-label">Select Document to Update <span class="required">*</span></label>
                        <div class="sop-list" id="sopList">
                            <!-- Existing SOPs will be populated here -->
                        </div>
                        <input type="hidden" id="selectedSOPId" name="selectedSOPId">
                    </div>

                    <div id="additionalInfo" class="additional-info">
                        <div class="form-group">
                            <label class="form-label" for="sopTitle">
                                Document Title <span class="required">*</span>
                            </label>
                            <input type="text" class="form-input" id="sopTitle" placeholder="Enter document title">
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="sopDescription">Description</label>
                            <textarea class="form-textarea" id="sopDescription" placeholder="Brief description of document purpose and scope"></textarea>
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="keywords">Keywords</label>
                            <input type="text" class="form-input" id="keywords" placeholder="Comma-separated keywords for search">
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="version">Version</label>
                            <input type="text" class="form-input" id="version" placeholder="1.0" value="1.0">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">
                            Document File <span class="required">*</span>
                        </label>
                        <div class="file-upload-section" id="fileUploadArea">
                            <div class="upload-icon">üìÑ</div>
                            <div class="upload-text">Select or drop file here</div>
                            <div class="upload-subtext">PDF, DOC, DOCX, PPT, PPTX, XLS, XLSX, TXT formats supported</div>
                            <input type="file" class="file-input" id="fileInput" accept=".pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.txt,.csv">
                        </div>
                        <div class="selected-file" id="selectedFile">
                            <div class="file-info">
                                <span>üìÑ</span>
                                <span id="fileName"></span>
                                <span style="margin-left: auto; color: #16a34a;">‚úì</span>
                            </div>
                        </div>
                    </div>

                    <button type="submit" class="btn-primary" id="submitBtn">
                        Upload Document
                    </button>
                    
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>

                    <div class="success-message" id="successMessage">
                        Document uploaded successfully and indexed for AI retrieval.
                    </div>
                </form>
            </div>
        </aside>

        <main class="main-content">
            <div class="content-header">
                <div class="content-title">Document Repository</div>
                <div class="content-subtitle">Browse and manage departmental documentation</div>
            </div>
            
            <div id="emptyState" class="empty-state">
                <div class="empty-icon">üìÅ</div>
                <div class="empty-title">Welcome to Document Repository</div>
                <div class="empty-text">
                    <p style="margin-bottom: 12px;">Choose a department from the <strong style="color: #3b82f6;">dropdown menu in the sidebar</strong> to view documents.</p>
                    <p style="font-size: 12px; color: #94a3b8;">Documents will auto-load in a moment, or you can select a department now.</p>
                </div>
            </div>

            <div id="explorerContainer" class="explorer-container">
                <div class="explorer-controls" style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center; padding: 16px; background: white; border-bottom: 1px solid #e2e8f0;">
                    <div class="search-container" style="flex: 1; min-width: 200px; max-width: 400px; position: relative;">
                        <input type="text" class="search-input" id="searchInput" placeholder="Search documents..." style="width: 100%; padding: 8px 12px 8px 36px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 14px; background: white;">
                        <span class="search-icon" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); font-size: 16px; opacity: 0.6;">üîç</span>
                    </div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <select id="departmentFilter" style="padding: 8px 12px; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 14px; background: white; cursor: pointer; min-width: 150px;">
                            <option value="">All Departments</option>
                        </select>
                    </div>
                    <div class="stats-panel">
                        <span id="documentCount">0 documents</span>
                        <span>‚Ä¢</span>
                        <span id="lastUpdated">Last updated: --</span>
                    </div>
                </div>
                
                <div id="folderGrid" class="folder-grid">
                    <!-- Dynamic content will be loaded here -->
                </div>
            </div>
        </main>
    </div>

    <!-- Document Preview Modal -->
    <div id="previewModal" class="preview-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10001; align-items: center; justify-content: center;">
        <div style="position: relative; width: 90%; height: 90%; max-width: 1200px; background: white; border-radius: 12px; display: flex; flex-direction: column; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; border-bottom: 1px solid #e5e7eb; background: #f9fafb; border-radius: 12px 12px 0 0;">
                <h2 id="previewTitle" style="margin: 0; font-size: 18px; font-weight: 600; color: #1f2937; flex: 1;">Document Preview</h2>
                <div style="display: flex; gap: 8px;">
                    <button onclick="openInNewTab()" style="background: white; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 6px; cursor: pointer; color: #374151; font-size: 14px; display: flex; align-items: center; gap: 4px;" title="Open in new tab">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                        Open in New Tab
                    </button>
                    <button onclick="closePreviewModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #6b7280; padding: 4px; line-height: 1;">√ó</button>
                </div>
            </div>
            <div id="previewContent" style="flex: 1; overflow: auto; padding: 0; display: flex; align-items: center; justify-content: center; background: #f3f4f6;">
                <!-- Preview content will be loaded here -->
            </div>
            <div style="padding: 12px 24px; border-top: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; background: #f9fafb; border-radius: 0 0 12px 12px;">
                <div id="previewInfo" style="font-size: 12px; color: #6b7280;">
                    <!-- File info will be shown here -->
                </div>
                <div style="display: flex; gap: 12px;">
                    <button onclick="downloadFromPreview()" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                        ‚¨áÔ∏è Download
                    </button>
                    <button onclick="closePreviewModal()" style="padding: 8px 16px; background: #f3f4f6; color: #374151; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Upload Status Modal -->
    <div class="upload-modal" id="uploadModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px); z-index: 10000; align-items: center; justify-content: center;">
        <div class="modal-content" style="background: white; border-radius: 16px; padding: 32px; max-width: 480px; width: 90%; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1); position: relative;">
            <button onclick="closeUploadModal()" style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 24px; cursor: pointer; color: #6b7280; padding: 4px; line-height: 1; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: all 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">&times;</button>
            <div class="modal-header" style="text-align: center; margin-bottom: 24px;">
                <div class="modal-title" id="modalTitle" style="font-size: 20px; font-weight: 600; color: #1e293b; margin-bottom: 8px;">Processing Document</div>
                <div class="modal-subtitle" id="modalSubtitle" style="font-size: 14px; color: #64748b;">Please wait while we process your document</div>
            </div>
            <div class="upload-steps">
                <div class="upload-step" id="step-hash" style="display: flex; align-items: center; gap: 12px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; opacity: 0.5; transition: all 0.3s;">
                    <div class="step-icon" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #f1f5f9; color: #94a3b8; font-size: 16px;">üîê</div>
                    <div class="step-text" style="flex: 1; font-size: 14px; color: #1e293b;">Calculating document hash...</div>
                    <div class="step-status" style="font-size: 12px; color: #94a3b8;"></div>
                </div>
                <div class="upload-step" id="step-duplicate" style="display: flex; align-items: center; gap: 12px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; opacity: 0.5; transition: all 0.3s;">
                    <div class="step-icon" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #f1f5f9; color: #94a3b8; font-size: 16px;">üîç</div>
                    <div class="step-text" style="flex: 1; font-size: 14px; color: #1e293b;">Checking for duplicates...</div>
                    <div class="step-status" style="font-size: 12px; color: #94a3b8;"></div>
                </div>
                <div class="upload-step" id="step-chunk" style="display: flex; align-items: center; gap: 12px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; opacity: 0.5; transition: all 0.3s;">
                    <div class="step-icon" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #f1f5f9; color: #94a3b8; font-size: 16px;">üìë</div>
                    <div class="step-text" style="flex: 1; font-size: 14px; color: #1e293b;">Creating document chunks with overlap...</div>
                    <div class="step-status" style="font-size: 12px; color: #94a3b8;"></div>
                </div>
                <div class="upload-step" id="step-upload" style="display: flex; align-items: center; gap: 12px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; opacity: 0.5; transition: all 0.3s;">
                    <div class="step-icon" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #f1f5f9; color: #94a3b8; font-size: 16px;">‚òÅÔ∏è</div>
                    <div class="step-text" style="flex: 1; font-size: 14px; color: #1e293b;">Uploading to cloud storage...</div>
                    <div class="step-status" style="font-size: 12px; color: #94a3b8;"></div>
                </div>
                <div class="upload-step" id="step-index" style="display: flex; align-items: center; gap: 12px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; opacity: 0.5; transition: all 0.3s;">
                    <div class="step-icon" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #f1f5f9; color: #94a3b8; font-size: 16px;">üîé</div>
                    <div class="step-text" style="flex: 1; font-size: 14px; color: #1e293b;">Indexing for search...</div>
                    <div class="step-status" style="font-size: 12px; color: #94a3b8;"></div>
                </div>
                <div class="upload-step" id="step-embeddings" style="display: flex; align-items: center; gap: 12px; padding: 12px 0; opacity: 0.5; transition: all 0.3s;">
                    <div class="step-icon" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #f1f5f9; color: #94a3b8; font-size: 16px;">üßÆ</div>
                    <div class="step-text" style="flex: 1; font-size: 14px; color: #1e293b;">Creating embeddings...</div>
                    <div class="step-status" style="font-size: 12px; color: #94a3b8;"></div>
                </div>
            </div>
            <div class="modal-progress" style="height: 4px; background: #f1f5f9; border-radius: 2px; overflow: hidden; margin: 24px 0;">
                <div class="modal-progress-fill" id="modalProgressFill" style="height: 100%; background: linear-gradient(90deg, #3b82f6 0%, #2563eb 100%); border-radius: 2px; transition: width 0.3s ease-out; width: 0%;"></div>
            </div>
            <div id="uploadCompleteActions" style="display: none; text-align: center; margin-top: 20px;">
                <button onclick="window.location.reload()" style="padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; margin-right: 10px;">Refresh Page</button>
                <button onclick="closeUploadModal()" style="padding: 10px 20px; background: #f3f4f6; color: #374151; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Close</button>
            </div>
        </div>
    </div>

    <!-- Load enhanced document icons -->
    <script src="js/document-icons-enhanced.js"></script>
    
    <script>
        // API Configuration - Azure Function endpoints and n8n webhook
        const API_CONFIG = {
            baseUrl: 'https://saxtechmegamindfunctions.azurewebsites.net/api',
            functionKey: 'zM5jG96cEf8xys3BptLRhgMoKAh9Ots6avbBOLuTGhSrAzFuxCpucw==', // Function key for authentication
            endpoints: {
                listDocuments: '/documents/list',
                uploadDocument: '/documents/upload-json-enhanced',  // Enhanced endpoint with chunking
                deleteDocument: '/documents/delete',  // Fixed route with slash
                downloadDocument: '/documents/download',
                previewDocument: '/documents/view',
                search: '/documents/search',  // Correct route with slash
                findByFile: '/documents/find-by-file',  // New find by filename endpoint
                generateSAS: '/GenerateSASToken',
                process: '/documents/upload-json-enhanced',  // Enhanced endpoint with chunking
                indexMaintenance: '/index/maintenance'  // Correct route with slash
            },
            blobStorage: {
                containerName: 'saxdocuments',
                baseUrl: 'https://saxtechmegamind.blob.core.windows.net'
            },
            azureSearch: {
                endpoint: 'https://saxmegamind-search.search.windows.net',
                indexName: 'sop-documents',
                apiKey: 'sZf5MvolOU8wqcM0sb1jI8XhICcOrTCfSIRl44vLmMAzSeA34CDO',
                apiVersion: '2023-11-01'
            },
            n8n: {
                webhookUrl: 'https://workflows.saxtechnology.com/webhook/sop-document-upload',
                enabled: true  // Toggle to enable/disable n8n integration
            }
        };

        // DOM elements
        const departmentSelect = document.getElementById('department');
        const sopTypeSelect = document.getElementById('sopType');
        const updateTypeSelect = document.getElementById('updateType');
        const existingSOPsDiv = document.getElementById('existingSOPs');
        const sopList = document.getElementById('sopList');
        const selectedSOPIdInput = document.getElementById('selectedSOPId');
        const additionalInfoDiv = document.getElementById('additionalInfo');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');
        const selectedFileDiv = document.getElementById('selectedFile');
        const fileName = document.getElementById('fileName');
        const form = document.getElementById('sopUploadForm');
        const submitBtn = document.getElementById('submitBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const successMessage = document.getElementById('successMessage');
        
        // Document explorer elements
        const emptyState = document.getElementById('emptyState');
        const explorerContainer = document.getElementById('explorerContainer');
        const searchInput = document.getElementById('searchInput');
        const documentCount = document.getElementById('documentCount');
        const lastUpdated = document.getElementById('lastUpdated');
        const folderGrid = document.getElementById('folderGrid');
        
        // Track current department for preview/download operations
        let currentDepartment = '';

        // Event listeners
        updateTypeSelect.addEventListener('change', handleUpdateTypeChange);
        departmentSelect.addEventListener('change', function() {
            loadDepartmentDocuments();
            loadExistingSOPs();
        });
        sopTypeSelect.addEventListener('change', loadExistingSOPs);
        fileUploadArea.addEventListener('click', () => fileInput.click());
        fileUploadArea.addEventListener('dragover', handleDragOver);
        fileUploadArea.addEventListener('dragleave', handleDragLeave);
        fileUploadArea.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);
        form.addEventListener('submit', handleFormSubmit);
        searchInput.addEventListener('input', handleSearch);
        
        // Add department filter listener
        const departmentFilter = document.getElementById('departmentFilter');
        if (departmentFilter) {
            departmentFilter.addEventListener('change', function() {
                const selectedDept = this.value;
                currentDepartment = selectedDept;
                
                if (!selectedDept || selectedDept === '') {
                    // Show all documents if "All Departments" is selected
                    loadAllDocuments();
                } else {
                    // Filter to selected department
                    filterDocumentsByDepartment(selectedDept);
                }
            });
        }
        
        // Load blob storage statistics on page load
        loadBlobStorageStats();
        
        // Load departments from localStorage (managed in admin.html)
        loadDepartmentsFromLocalStorage();
        
        // Auto-load blob documents on page load
        setTimeout(() => {
            loadBlobDocuments();
        }, 500);
        
        // Upload Modal Functions
        function showUploadModal() {
            // Reset error display flag when starting new upload
            window.isErrorDisplayed = false;
            
            const modal = document.getElementById('uploadModal');
            modal.style.display = 'flex';
            
            // Reset all steps
            const steps = ['step-hash', 'step-duplicate', 'step-chunk', 'step-upload', 'step-index', 'step-embeddings'];
            steps.forEach(stepId => {
                const step = document.getElementById(stepId);
                step.style.opacity = '0.5';
                step.querySelector('.step-status').textContent = '';
                // Reset colors
                step.querySelector('.step-icon').style.background = '#f1f5f9';
                step.querySelector('.step-icon').style.color = '#94a3b8';
            });
            
            // Reset modal state
            document.getElementById('modalTitle').textContent = 'Processing Document';
            document.getElementById('modalTitle').style.color = '#1e293b';
            document.getElementById('modalSubtitle').textContent = 'Please wait while we process your document';
            document.getElementById('modalSubtitle').style.color = '#64748b';
            document.getElementById('modalProgressFill').style.width = '0%';
            document.getElementById('uploadCompleteActions').style.display = 'none';
            
            // Don't start fake animation - wait for real progress updates
        }
        
        async function simulateUploadSteps() {
            const steps = [
                { id: 'step-hash', duration: 1000 },
                { id: 'step-duplicate', duration: 1500 },
                { id: 'step-chunk', duration: 2000 },
                { id: 'step-upload', duration: 2500 },
                { id: 'step-index', duration: 2000 },
                { id: 'step-embeddings', duration: 3000 }
            ];
            
            const progressFill = document.getElementById('modalProgressFill');
            const modalTitle = document.getElementById('modalTitle');
            const modalSubtitle = document.getElementById('modalSubtitle');
            
            for (let i = 0; i < steps.length; i++) {
                const step = document.getElementById(steps[i].id);
                
                // Activate current step
                step.style.opacity = '1';
                step.querySelector('.step-icon').style.background = 'rgba(59, 130, 246, 0.1)';
                step.querySelector('.step-icon').style.color = '#3b82f6';
                
                // Update progress
                const progress = ((i + 1) / steps.length) * 100;
                progressFill.style.width = progress + '%';
                
                // Wait for step duration
                await new Promise(resolve => setTimeout(resolve, steps[i].duration));
                
                // Complete step
                step.querySelector('.step-icon').style.background = 'rgba(16, 185, 129, 0.1)';
                step.querySelector('.step-icon').style.color = '#10b981';
                step.querySelector('.step-status').textContent = '‚úì';
                step.querySelector('.step-status').style.color = '#10b981';
            }
            
            // Update modal to show completion
            modalTitle.textContent = 'Upload Complete!';
            modalSubtitle.textContent = 'Your document has been successfully processed';
            
            // Show action buttons
            document.getElementById('uploadCompleteActions').style.display = 'block';
        }
        
        function updateUploadProgress(step, title, subtitle) {
            const modalTitle = document.getElementById('modalTitle');
            const modalSubtitle = document.getElementById('modalSubtitle');
            const progressFill = document.getElementById('modalProgressFill');
            const uploadCompleteActions = document.getElementById('uploadCompleteActions');
            
            const stepMap = {
                'hash': { stepId: 'step-hash', progress: 16 },
                'duplicate': { stepId: 'step-duplicate', progress: 32 },
                'chunk': { stepId: 'step-chunk', progress: 48 },
                'upload': { stepId: 'step-upload', progress: 64 },
                'index': { stepId: 'step-index', progress: 80 },
                'embeddings': { stepId: 'step-embeddings', progress: 100 },
                'complete': { stepId: null, progress: 100 }
            };
            
            // Update modal text
            modalTitle.textContent = title;
            if (subtitle) {
                modalSubtitle.textContent = subtitle;
            }
            
            if (step === 'complete') {
                // Show success state
                modalTitle.style.color = '#10b981';
                modalSubtitle.style.color = '#64748b';
                progressFill.style.width = '100%';
                
                // Show only Close button for success - replaces both Refresh and Close buttons
                uploadCompleteActions.innerHTML = `
                    <div style="text-align: center; width: 100%; margin-top: 20px;">
                        <button onclick="closeUploadModalAndRefresh()" style="padding: 12px 24px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">Close</button>
                    </div>
                `;
                uploadCompleteActions.style.display = 'block';
                
                // Mark all steps as complete
                const allSteps = ['step-hash', 'step-duplicate', 'step-chunk', 'step-upload', 'step-index', 'step-embeddings'];
                allSteps.forEach(stepId => {
                    const stepElement = document.getElementById(stepId);
                    stepElement.style.opacity = '1';
                    stepElement.querySelector('.step-icon').style.background = 'rgba(16, 185, 129, 0.1)';
                    stepElement.querySelector('.step-icon').style.color = '#10b981';
                    stepElement.querySelector('.step-status').textContent = '‚úì';
                    stepElement.querySelector('.step-status').style.color = '#10b981';
                });
            } else {
                // Show progress state
                const stepInfo = stepMap[step];
                if (stepInfo) {
                    progressFill.style.width = stepInfo.progress + '%';
                    
                    if (stepInfo.stepId) {
                        // Complete previous steps
                        const allSteps = ['step-hash', 'step-duplicate', 'step-chunk', 'step-upload', 'step-index', 'step-embeddings'];
                        const currentIndex = allSteps.indexOf(stepInfo.stepId);
                        
                        for (let i = 0; i < currentIndex; i++) {
                            const prevStepElement = document.getElementById(allSteps[i]);
                            prevStepElement.style.opacity = '1';
                            prevStepElement.querySelector('.step-icon').style.background = 'rgba(16, 185, 129, 0.1)';
                            prevStepElement.querySelector('.step-icon').style.color = '#10b981';
                            prevStepElement.querySelector('.step-status').textContent = '‚úì';
                            prevStepElement.querySelector('.step-status').style.color = '#10b981';
                        }
                        
                        // Activate current step
                        const stepElement = document.getElementById(stepInfo.stepId);
                        stepElement.style.opacity = '1';
                        stepElement.querySelector('.step-icon').style.background = 'rgba(59, 130, 246, 0.1)';
                        stepElement.querySelector('.step-icon').style.color = '#3b82f6';
                        stepElement.querySelector('.step-text').textContent = subtitle || stepElement.querySelector('.step-text').textContent;
                    }
                }
            }
        }
        
        function showUploadError(errorMessage) {
            // Prevent double-calling by checking if error is already displayed
            if (window.isErrorDisplayed) {
                console.log('Error already displayed, ignoring duplicate call');
                return;
            }
            window.isErrorDisplayed = true;
            
            console.log('=== SHOW UPLOAD ERROR DEBUG ===');
            console.log('Error message:', errorMessage);
            
            // Force the modal to be visible first
            const modal = document.getElementById('uploadModal');
            if (modal) {
                modal.style.display = 'flex';
                console.log('Modal display set to flex');
            } else {
                console.error('Upload modal not found!');
            }
            
            const modalTitle = document.getElementById('modalTitle');
            const modalSubtitle = document.getElementById('modalSubtitle');
            const uploadCompleteActions = document.getElementById('uploadCompleteActions');
            
            console.log('Modal elements found:', {
                modalTitle: !!modalTitle,
                modalSubtitle: !!modalSubtitle,
                uploadCompleteActions: !!uploadCompleteActions
            });
            
            if (!modalTitle || !modalSubtitle || !uploadCompleteActions) {
                console.error('Critical: Modal elements not found! Showing alert fallback.');
                alert('Upload failed: ' + errorMessage);
                return;
            }
            
            // Force clear any ongoing animations or states
            try {
                // Show error state with maximum priority
                modalTitle.textContent = '‚ùå Upload Failed';
                modalTitle.style.color = '#dc2626';
                modalTitle.style.fontWeight = 'bold';
                
                modalSubtitle.textContent = errorMessage;
                modalSubtitle.style.color = '#dc2626';
                modalSubtitle.style.fontSize = '14px';
                
                console.log('Updated modal title and subtitle');
                
                // Find and mark the current active step as failed
                const activeSteps = document.querySelectorAll('.upload-step');
                console.log('Found upload steps:', activeSteps.length);
                
                // Mark the last visible step as failed
                let lastVisibleStep = null;
                activeSteps.forEach((step, index) => {
                    const opacity = parseFloat(window.getComputedStyle(step).opacity);
                    if (opacity >= 1) {
                        lastVisibleStep = step;
                    }
                });
                
                if (lastVisibleStep) {
                    console.log('Marking last visible step as failed');
                    const stepIcon = lastVisibleStep.querySelector('.step-icon');
                    const stepStatus = lastVisibleStep.querySelector('.step-status');
                    
                    if (stepIcon) {
                        stepIcon.style.background = 'rgba(220, 38, 38, 0.1)';
                        stepIcon.style.color = '#dc2626';
                    }
                    if (stepStatus) {
                        stepStatus.textContent = '‚úó';
                        stepStatus.style.color = '#dc2626';
                        stepStatus.style.fontSize = '16px';
                        stepStatus.style.fontWeight = 'bold';
                    }
                } else {
                    console.log('No active step found to mark as failed');
                }
                
                // Force show action buttons with retry option - use more aggressive CSS
                uploadCompleteActions.innerHTML = `
                    <div style="text-align: center; width: 100%; margin-top: 20px; display: block !important; visibility: visible !important; opacity: 1 !important;">
                        <button onclick="window.retryUpload()" style="padding: 12px 20px; background: #f59e0b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; margin-right: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: inline-block !important;">üîÑ Retry Upload</button>
                        <button onclick="window.closeUploadModal ? window.closeUploadModal() : closeUploadModal()" style="padding: 12px 20px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: inline-block !important;">Close</button>
                    </div>
                `;
                
                // Use more aggressive CSS to force visibility
                uploadCompleteActions.style.cssText = 'display: block !important; text-align: center; margin-top: 20px; visibility: visible !important; opacity: 1 !important; z-index: 9999;';
                
                // Add a delay to ensure DOM has processed the changes
                setTimeout(() => {
                    uploadCompleteActions.style.display = 'block';
                    uploadCompleteActions.style.visibility = 'visible';
                    uploadCompleteActions.style.opacity = '1';
                    console.log('Updated action buttons (delayed enforcement)');
                }, 50);
                
                console.log('Updated action buttons');
                
                // Reset form button state
                if (window.submitBtn || document.getElementById('submitBtn')) {
                    const btn = window.submitBtn || document.getElementById('submitBtn');
                    btn.disabled = false;
                    btn.textContent = 'Upload Document';
                    console.log('Reset submit button');
                }
                
                console.log('=== ERROR DISPLAY COMPLETE ===');
                
            } catch (e) {
                console.error('Error in showUploadError:', e);
                alert('Upload failed: ' + errorMessage);
            }
        }
        
        // Make showUploadError globally accessible
        window.showUploadError = showUploadError;
        
        function retryUpload() {
            console.log('Retry upload initiated');
            
            // Reset error display flag for retry
            window.isErrorDisplayed = false;
            
            // Reset modal state without closing
            const modalTitle = document.getElementById('modalTitle');
            const modalSubtitle = document.getElementById('modalSubtitle');
            const uploadCompleteActions = document.getElementById('uploadCompleteActions');
            
            modalTitle.textContent = 'Uploading Document';
            modalTitle.style.color = '#111827';
            modalSubtitle.textContent = 'Your document is being processed...';
            modalSubtitle.style.color = '#6b7280';
            
            // Reset progress steps
            resetUploadProgress();
            
            // Hide actions
            uploadCompleteActions.style.display = 'none';
            
            // Retry the upload with the last file
            if (window.lastUploadedFile && window.lastUploadFormData) {
                console.log('Retrying upload with cached file:', window.lastUploadedFile.name);
                
                // Disable submit button during retry
                submitBtn.disabled = true;
                submitBtn.textContent = 'Processing...';
                
                // Call the same upload method as in the original form submission
                uploadDocumentMultipart(window.lastUploadFormData)
                    .then(response => {
                        updateUploadProgress('complete', 'Upload Complete!', 'Your document has been successfully processed');
                        completeUpload();
                    })
                    .catch(error => {
                        console.error('Retry upload failed:', error);
                        const errorMessage = error.message === 'Upload failed - see modal for details' 
                            ? 'Retry failed due to server error - check console for details'
                            : (error.message || 'An error occurred during retry upload');
                        
                        showUploadError(errorMessage);
                    });
            } else {
                console.error('No cached file/form data for retry');
                showUploadError('Cannot retry: no file data available. Please close and try again.');
            }
        }
        
        // Helper function to reset upload progress state
        function resetUploadProgress() {
            const steps = ['step-hash', 'step-duplicate', 'step-chunk', 'step-upload', 'step-index', 'step-embeddings'];
            steps.forEach(stepId => {
                const step = document.getElementById(stepId);
                step.style.opacity = '0.5';
                step.querySelector('.step-status').textContent = '';
                step.querySelector('.step-icon').style.background = '#f1f5f9';
                step.querySelector('.step-icon').style.color = '#94a3b8';
            });
            
            // Reset progress bar
            document.getElementById('modalProgressFill').style.width = '0%';
        }
        
        // Make retryUpload globally accessible
        window.retryUpload = retryUpload;
        
        function closeUploadModal() {
            console.log('Closing upload modal');
            const modal = document.getElementById('uploadModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Reset error display flag
            window.isErrorDisplayed = false;
            
            // Reset form state
            const btn = window.submitBtn || document.getElementById('submitBtn');
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Upload Document';
            }
            
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.display = 'none';
            }
            
            // Clear cached upload data
            window.lastUploadedFile = null;
            window.lastUploadFormData = null;
            
            console.log('Upload modal closed and form reset');
            
            // Auto-refresh page to reload documents after any upload attempt
            console.log('Auto-refreshing page to reload document list...');
            setTimeout(() => {
                window.location.reload();
            }, 500); // Small delay to ensure modal closes smoothly
        }
        
        // Make closeUploadModal globally accessible
        window.closeUploadModal = closeUploadModal;
        
        // Function to close modal and refresh page for successful uploads
        function closeUploadModalAndRefresh() {
            console.log('Closing upload modal and refreshing page after successful upload');
            const modal = document.getElementById('uploadModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Reset error display flag
            window.isErrorDisplayed = false;
            
            // Clear cached upload data
            window.lastUploadedFile = null;
            window.lastUploadFormData = null;
            
            // Refresh page immediately to show updated document list
            window.location.reload();
        }
        
        // Make closeUploadModalAndRefresh globally accessible
        window.closeUploadModalAndRefresh = closeUploadModalAndRefresh;

        function loadDepartmentDocuments() {
            const selectedDept = departmentSelect.value;
            currentDepartment = selectedDept; // Track for preview/download
            
            if (!selectedDept) {
                // Load all documents if no department selected
                loadAllDocuments();
                return;
            }

            // Filter already loaded documents by department
            filterDocumentsByDepartment(selectedDept);
        }
        
        function loadBlobDocuments() {
            // Show loading state
            emptyState.style.display = 'none';
            explorerContainer.style.display = 'block';
            documentCount.textContent = '0 documents';
            lastUpdated.textContent = 'Last updated: --';
            folderGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;">Loading documents from blob storage...</div>';

            // Fetch documents from blob storage
            fetchBlobDocuments()
                .then(data => {
                    if (!data || !data.documents || data.documents.length === 0) {
                        showEmptyRepository();
                        return;
                    }

                    // Update stats
                    documentCount.textContent = `${data.documents.length} documents in blob storage`;
                    lastUpdated.textContent = `Last updated: ${data.lastModified || '--'}`;
                    
                    // Store all documents for filtering
                    window.allBlobDocuments = data.documents;
                    
                    // Build simple document list
                    buildBlobDocumentList(data.documents);
                })
                .catch(error => {
                    console.error('Error loading blob documents:', error);
                    showEmptyRepository();
                });
        }
        
        function filterDocumentsByDepartment(department) {
            if (!window.allDocumentsData) {
                loadAllDocuments();
                return;
            }
            
            const filteredDepartments = {};
            
            // Try exact match first, then case-insensitive match
            let foundDept = null;
            Object.keys(window.allDocumentsData.departments).forEach(deptKey => {
                if (deptKey === department) {
                    foundDept = deptKey;
                } else if (deptKey.toLowerCase() === department.toLowerCase()) {
                    foundDept = deptKey;
                }
            });
            
            if (foundDept) {
                filteredDepartments[foundDept] = window.allDocumentsData.departments[foundDept];
            }
            
            if (Object.keys(filteredDepartments).length > 0) {
                const totalDocs = Object.values(filteredDepartments).reduce((sum, folders) => {
                    return sum + Object.values(folders).reduce((s, docs) => s + docs.length, 0);
                }, 0);
                
                documentCount.textContent = `${totalDocs} documents in ${department}`;
                buildDepartmentStructure(filteredDepartments);
            } else {
                showEmptyDepartment(department);
            }
        }

        async function fetchBlobDocuments() {
            const startTime = performance.now();
            console.log('üîç Starting blob storage document fetch...');
            
            try {
                // Call Azure Function to list blob storage documents (should be fast)
                const fetchStartTime = performance.now();
                console.log('‚òÅÔ∏è Getting documents from blob storage...');
                
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.generateSAS}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        containerName: API_CONFIG.blobStorage.containerName,
                        listBlobs: true  // Flag to list all blobs instead of generating SAS
                    })
                });
                
                const fetchEndTime = performance.now();
                console.log(`‚ö° Blob listing completed in ${(fetchEndTime - fetchStartTime).toFixed(2)}ms`);

                if (!response.ok) {
                    throw new Error(`Blob listing HTTP ${response.status}: ${response.statusText}`);
                }

                const blobData = await response.json();
                console.log(`üìä Received ${blobData.blobs?.length || 0} blobs from storage`);
                
                // Transform blob data into document format
                const documents = (blobData.blobs || []).map(blob => ({
                    id: blob.name,
                    title: blob.name.split('/').pop(), // Get filename
                    fileName: blob.name.split('/').pop(),
                    size: blob.properties?.contentLength || 0,
                    lastModified: blob.properties?.lastModified,
                    contentType: blob.properties?.contentType,
                    department: blob.name.split('/')[0], // First folder as department
                    url: `${API_CONFIG.blobStorage.baseUrl}/${API_CONFIG.blobStorage.containerName}/${blob.name}`
                }));
                
                const endTime = performance.now();
                console.log(`üèÅ Blob document processing completed in ${(endTime - startTime).toFixed(2)}ms (${documents.length} documents)`);
                
                return {
                    documents: documents,
                    lastModified: documents.length > 0 ? 
                        formatDateToEST(Math.max(...documents.map(d => new Date(d.lastModified).getTime()))) : '--'
                };
                
            } catch (error) {
                console.error('Error fetching blob documents:', error);
                const endTime = performance.now();
                console.log(`‚ùå Blob fetch failed in ${(endTime - startTime).toFixed(2)}ms`);
                throw error;
            }
        }
        
        function buildBlobDocumentList(documents) {
            folderGrid.innerHTML = '';
            
            if (!documents || documents.length === 0) {
                folderGrid.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #64748b;">
                        <div style="font-size: 24px; margin-bottom: 12px;">üìÑ</div>
                        <div style="font-weight: 500; margin-bottom: 8px;">No Documents Found</div>
                        <div style="font-size: 13px;">No documents have been uploaded to blob storage yet.</div>
                    </div>
                `;
                return;
            }
            
            // Create simple document list
            const documentList = document.createElement('div');
            documentList.style.cssText = 'display: grid; gap: 12px; padding: 16px;';
            
            documents.forEach(doc => {
                const docItem = createSimpleBlobDocumentItem(doc);
                documentList.appendChild(docItem);
            });
            
            folderGrid.appendChild(documentList);
        }
        
        function createSimpleBlobDocumentItem(doc) {
            const docDiv = document.createElement('div');
            docDiv.style.cssText = 'border: 1px solid #e5e7eb; border-radius: 8px; background: white; padding: 16px; transition: all 0.2s; cursor: pointer;';
            docDiv.onmouseover = () => docDiv.style.background = '#f9fafb';
            docDiv.onmouseout = () => docDiv.style.background = 'white';
            
            const fileExt = doc.fileName ? doc.fileName.split('.').pop().toLowerCase() : '';
            const typeInfo = getFileTypeInfo(fileExt);
            const enhancedIcon = window.getFileTypeIcon ? window.getFileTypeIcon(doc.fileName) : typeInfo;
            
            docDiv.innerHTML = `
                <div style="display: flex; gap: 16px; align-items: center;">
                    <div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; border-radius: 8px; background: ${enhancedIcon.gradient || typeInfo.gradient}; flex-shrink: 0;">
                        ${enhancedIcon.svg || (typeof typeInfo.icon === 'string' && typeInfo.icon.includes('<svg') ? typeInfo.icon : `<span style="color: white; font-size: 24px;">${typeInfo.icon}</span>`)}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 600; color: #1e293b; margin-bottom: 4px;">${doc.title}</div>
                        <div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">
                            Size: ${formatFileSize(doc.size)} ‚Ä¢ Modified: ${formatDateToEST(doc.lastModified)}
                        </div>
                        <div style="font-size: 11px; color: #94a3b8;">
                            üì¶ ${doc.department || 'No Department'} ‚Ä¢ üîó Blob Storage
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="downloadBlobDocument('${doc.url}', '${doc.fileName}')" style="padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Download</button>
                    </div>
                </div>
            `;
            
            return docDiv;
        }
        
        function downloadBlobDocument(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        async function loadBlobStorageStats() {
            try {
                const data = await fetchBlobDocuments();
                if (data && data.documents) {
                    document.getElementById('blobDocCount').textContent = data.documents.length;
                    document.getElementById('blobLastUpdate').textContent = data.lastModified.split(' ')[0]; // Just date
                }
            } catch (error) {
                console.error('Error loading blob stats:', error);
                document.getElementById('blobDocCount').textContent = '0';
                document.getElementById('blobLastUpdate').textContent = 'Error';
            }
        }
        
                
                // Transform search results into department > folder structure
                const departments = {};
                let totalDocuments = 0;
                let lastUpdated = '--';
                
                // Azure AI Search returns results in 'value' array
                let allDocuments = searchResults.value || [];
                
                // Deduplicate documents that are split into chunks
                const uniqueDocumentsMap = new Map();
                const duplicateCountMap = new Map();
                
                // First pass: Count occurrences for duplicate detection (O(n))
                allDocuments.forEach(doc => {
                    let uniqueKey = '';
                    if (doc.fileName) {
                        uniqueKey = doc.fileName;
                    } else if (doc.title) {
                        uniqueKey = doc.title;
                    } else if (doc.id) {
                        const baseId = doc.id.replace(/_chunk\d+$/i, '').replace(/-chunk-\d+$/i, '').replace(/\.chunk\d+$/i, '');
                        uniqueKey = baseId;
                    }
                    
                    if (uniqueKey) {
                        duplicateCountMap.set(uniqueKey, (duplicateCountMap.get(uniqueKey) || 0) + 1);
                    }
                });
                
                // Second pass: Store unique documents with chunked flag (O(n))
                allDocuments.forEach(doc => {
                    // Use fileName as the unique key, or fall back to title
                    let uniqueKey = '';
                    
                    if (doc.fileName) {
                        uniqueKey = doc.fileName;
                    } else if (doc.title) {
                        uniqueKey = doc.title;
                    } else if (doc.id) {
                        // For chunked documents, extract base ID
                        const baseId = doc.id.replace(/_chunk\d+$/i, '').replace(/-chunk-\d+$/i, '').replace(/\.chunk\d+$/i, '');
                        uniqueKey = baseId;
                    }
                    
                    if (uniqueKey && !uniqueDocumentsMap.has(uniqueKey)) {
                        // Store the first occurrence with pre-calculated chunked flag
                        uniqueDocumentsMap.set(uniqueKey, {
                            ...doc,
                            isChunked: (duplicateCountMap.get(uniqueKey) || 0) > 1
                        });
                    } else if (uniqueKey && uniqueDocumentsMap.has(uniqueKey)) {
                        // Merge metadata from duplicate chunks
                        const existingDoc = uniqueDocumentsMap.get(uniqueKey);
                        
                        // Keep the larger file size
                        if (doc.fileSize && (!existingDoc.fileSize || doc.fileSize > existingDoc.fileSize)) {
                            existingDoc.fileSize = doc.fileSize;
                        }
                        
                        // Merge other metadata
                        if (!existingDoc.department && doc.department) {
                            existingDoc.department = doc.department;
                        }
                        if (!existingDoc.description && doc.description) {
                            existingDoc.description = doc.description;
                        }
                    }
                });
                
                // Convert map back to array
                const documents = Array.from(uniqueDocumentsMap.values());
                
                const dedupeTime = performance.now();
                console.log(`‚ö° Deduplicated ${allDocuments.length} chunks to ${documents.length} unique documents in ${(dedupeTime - startTime).toFixed(2)}ms`);
                
                if (documents && documents.length > 0) {
                    // Group documents by department, then by documentType
                    documents.forEach(doc => {
                        const deptName = doc.department || 'General';
                        const folderName = doc.documentType || 'General';
                        
                        if (!departments[deptName]) {
                            departments[deptName] = {};
                        }
                        if (!departments[deptName][folderName]) {
                            departments[deptName][folderName] = [];
                        }
                        
                        departments[deptName][folderName].push({
                            id: doc.id,
                            title: doc.title || doc.fileName,
                            fileName: doc.fileName,  // Always store the actual filename
                            description: doc.description || '',
                            lastModified: doc.modifiedDate || doc.createdDate,
                            uploadDate: doc.createdDate,
                            type: folderName.substring(0, 3).toUpperCase(),
                            author: doc.author || 'SAX User',
                            size: doc.fileSize || null,
                            version: doc.version || '1.0',
                            department: doc.department,
                            sha256Hash: doc.contentHash,  // Use contentHash field and alias it as sha256Hash
                            contentHash: doc.contentHash,
                            status: doc.status,
                            keywords: doc.keywords,
                            tags: doc.tags,
                            indexed: doc.status === 'indexed' || doc.status === 'completed' || doc.status === 'Active'
                        });
                        totalDocuments++;
                    });
                    
                    // Get the most recent update date
                    const dates = documents.filter(d => d.modifiedDate || d.uploadDate || d.createdDate)
                                          .map(d => d.modifiedDate || d.uploadDate || d.createdDate);
                    if (dates.length > 0) {
                        // Find the most recent date string
                        const mostRecentStr = dates.sort((a, b) => new Date(b) - new Date(a))[0];
                        // Format to EST
                        lastUpdated = formatDateToEST(mostRecentStr);
                    }
                }
                
                const endTime = performance.now();
                console.log(`üèÅ Document processing completed in ${(endTime - startTime).toFixed(2)}ms (${totalDocuments} documents)`);
                
                const result = {
                    departments: departments,
                    stats: {
                        totalDocuments: totalDocuments,
                        lastUpdated: lastUpdated
                    }
                };
                
                // Save to cache for next time
                try {
                    localStorage.setItem(cacheKey, JSON.stringify(result));
                    localStorage.setItem(cacheTimestampKey, Date.now().toString());
                    console.log('üíæ Cached document data for future loads');
                } catch (e) {
                    console.warn('Cache save error:', e);
                }
                
                return result;
            } catch (error) {
                console.error('Azure Search query failed:', error);
                // Return empty structure if search fails
                return {
                    departments: {},
                    stats: {
                        totalDocuments: 0,
                        lastUpdated: '--'
                    }
                };
            }
        }

        function showEmptyDepartment(department) {
            folderGrid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #64748b;">
                    <div style="font-size: 24px; margin-bottom: 12px;">üìÅ</div>
                    <div style="font-weight: 500; margin-bottom: 8px;">No Documents Found</div>
                    <div style="font-size: 13px;">No documents have been uploaded to the ${department} department yet.</div>
                </div>
            `;
            documentCount.textContent = '0 documents';
            lastUpdated.textContent = 'Last updated: --';
        }
        
        function showEmptyRepository() {
            folderGrid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #64748b;">
                    <div style="font-size: 24px; margin-bottom: 12px;">üìÅ</div>
                    <div style="font-weight: 500; margin-bottom: 8px;">No Documents in Repository</div>
                    <div style="font-size: 13px;">Start by uploading documents using the form on the left.</div>
                </div>
            `;
            documentCount.textContent = '0 documents';
            lastUpdated.textContent = 'Last updated: --';
        }
        
        function buildDepartmentStructure(departments) {
            folderGrid.innerHTML = '';
            
            if (!departments || Object.keys(departments).length === 0) {
                showEmptyRepository();
                return;
            }
            
            // Create a section for each department
            Object.keys(departments).sort().forEach(deptName => {
                const deptSection = document.createElement('div');
                deptSection.className = 'department-section';
                deptSection.style.cssText = 'margin-bottom: 32px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px;';
                
                // Department header
                const deptHeader = document.createElement('h3');
                deptHeader.style.cssText = 'margin: 0 0 16px 0; color: #1f2937; font-size: 16px; font-weight: 600; padding-bottom: 12px; border-bottom: 1px solid #e5e7eb;';
                deptHeader.innerHTML = `üè´ ${deptName} Department`;
                deptSection.appendChild(deptHeader);
                
                // Create folder structure for this department
                const folders = departments[deptName];
                const folderContainer = document.createElement('div');
                folderContainer.className = 'folder-grid';
                
                Object.keys(folders).sort().forEach(folderName => {
                    const documents = folders[folderName] || [];
                    
                    const folderCard = document.createElement('div');
                    folderCard.className = 'folder-card expanded'; // Start expanded
                    
                    const folderHeader = document.createElement('div');
                    folderHeader.className = 'folder-header';
                    folderHeader.innerHTML = `
                        <div class="folder-info">
                            <span class="folder-icon">‚ñº</span>
                            <span class="folder-name">${folderName}</span>
                        </div>
                        <span class="folder-count">${documents.length}</span>
                    `;
                    
                    const folderContent = document.createElement('div');
                    folderContent.className = 'folder-content';
                    
                    const documentList = document.createElement('div');
                    documentList.className = 'document-list';
                    
                    if (documents.length === 0) {
                        documentList.innerHTML = `
                            <div style="text-align: center; padding: 20px; color: #94a3b8; font-size: 13px;">
                                No documents in this category yet.
                            </div>
                        `;
                    } else {
                        documents.forEach(doc => {
                            const docItem = createDocumentItem(doc);
                            documentList.appendChild(docItem);
                        });
                    }
                    
                    folderContent.appendChild(documentList);
                    
                    // Toggle folder expand/collapse
                    folderHeader.addEventListener('click', () => {
                        folderCard.classList.toggle('expanded');
                        const icon = folderHeader.querySelector('.folder-icon');
                        icon.textContent = folderCard.classList.contains('expanded') ? '‚ñº' : '‚ñ∂';
                    });
                    
                    folderCard.appendChild(folderHeader);
                    folderCard.appendChild(folderContent);
                    folderContainer.appendChild(folderCard);
                });
                
                deptSection.appendChild(folderContainer);
                folderGrid.appendChild(deptSection);
            });
        }

        function buildFolderStructure(folders) {
            folderGrid.innerHTML = '';
            
            if (!folders || Object.keys(folders).length === 0) {
                folderGrid.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #64748b;">
                        <div style="font-size: 24px; margin-bottom: 12px;">üìÅ</div>
                        <div style="font-weight: 500; margin-bottom: 8px;">No Document Categories</div>
                        <div style="font-size: 13px;">No document categories have been created for this department yet.</div>
                    </div>
                `;
                return;
            }
            
            Object.keys(folders).forEach(folderName => {
                const documents = folders[folderName] || [];
                
                const folderCard = document.createElement('div');
                folderCard.className = 'folder-card';
                
                const folderHeader = document.createElement('div');
                folderHeader.className = 'folder-header';
                folderHeader.innerHTML = `
                    <div class="folder-info">
                        <span class="folder-icon">‚ñ∂</span>
                        <span class="folder-name">${folderName}</span>
                    </div>
                    <span class="folder-count">${documents.length}</span>
                `;
                
                const folderContent = document.createElement('div');
                folderContent.className = 'folder-content';
                
                const documentList = document.createElement('div');
                documentList.className = 'document-list';
                
                if (documents.length === 0) {
                    documentList.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #94a3b8; font-size: 13px;">
                            No documents in this category yet.
                        </div>
                    `;
                } else {
                    // Add documents to folder
                    documents.forEach(doc => {
                        const docItem = createDocumentItem(doc);
                        documentList.appendChild(docItem);
                    });
                }
                
                folderContent.appendChild(documentList);
                
                // Toggle folder expand/collapse
                folderHeader.addEventListener('click', () => {
                    folderCard.classList.toggle('expanded');
                });
                
                folderCard.appendChild(folderHeader);
                folderCard.appendChild(folderContent);
                folderGrid.appendChild(folderCard);
            });
        }

        function createDocumentItem(doc) {
            const docDiv = document.createElement('div');
            // Don't use document-item class to avoid CSS conflicts
            docDiv.setAttribute('data-search', `${doc.title} ${doc.description || ''} ${doc.author || ''}`.toLowerCase());
            docDiv.setAttribute('data-department', doc.department || '');
            
            // Use fileName for display, not title (title might be user-entered text)
            let displayName = doc.fileName || doc.title || 'Unknown Document';
            
            // Remove "Part x/x" from display name if present
            displayName = displayName.replace(/\s*-?\s*Part\s+\d+\/\d+/gi, '').trim();
            const fileExt = displayName ? displayName.split('.').pop().toLowerCase() : '';
            const typeInfo = getFileTypeInfo(fileExt);
            
            // Format file size
            const fileSize = doc.size ? formatFileSize(doc.size) : '';
            
            // Format dates to EST
            const uploadDate = doc.uploadDate ? formatDateToEST(doc.uploadDate) : null;
            const modifiedDate = doc.lastModified ? formatDateToEST(doc.lastModified) : uploadDate || '';
            
            // Build metadata items
            const metaItems = [];
            if (modifiedDate) {
                metaItems.push(`<span class="meta-item"><span style="font-size: 10px;">üìÖ</span> ${modifiedDate}</span>`);
            }
            if (fileSize) {
                metaItems.push(`<span class="meta-item"><span style="font-size: 10px;">üì¶</span> ${fileSize}</span>`);
            }
            
            // Add indexing status (only show if indexed, hide Processing status)
            if (doc.indexed !== false) {
                metaItems.push(`<span class="meta-item indexed"><span style="font-size: 10px;">‚úì</span> Indexed</span>`);
            }
            
            // Add vectorization status
            if (doc.vectorized) {
                metaItems.push(`<span class="meta-item indexed"><span style="font-size: 10px;">üßÆ</span> Vectorized</span>`);
            }
            
            // Add chunk count if available
            if (doc.chunkCount) {
                metaItems.push(`<span class="meta-item chunks"><span style="font-size: 10px;">üìë</span> ${doc.chunkCount} chunks</span>`);
            }
            
            // Add chunked indicator if document is chunked
            if (doc.isChunked) {
                metaItems.push(`<span class="meta-item chunks" style="background: #fef3c7; color: #92400e; padding: 2px 6px; border-radius: 4px;"><span style="font-size: 10px;">üìë</span> Chunked</span>`);
            }
            
            // Add conversion method if available
            if (doc.conversionMethod) {
                const methodIcon = doc.conversionMethod === 'OCR' ? 'üëÅÔ∏è' : doc.conversionMethod === 'Excel' ? 'üìä' : 'üìÑ';
                metaItems.push(`<span class="meta-item"><span style="font-size: 10px;">${methodIcon}</span> ${doc.conversionMethod}</span>`);
            }
            
            // Add department if available
            if (doc.department) {
                metaItems.push(`<span class="meta-item"><span style="font-size: 10px;">üè¢</span> ${doc.department}</span>`);
            }
            
            // Create better formatted metadata with labels
            const formattedMeta = [];
            if (displayName) {
                formattedMeta.push(`<span class="meta-item" style="font-weight: 500;"><span style="font-size: 10px;">üìÑ</span> ${displayName}</span>`);
            }
            if (modifiedDate) {
                formattedMeta.push(`<span class="meta-item"><span style="font-size: 10px;">üìÖ</span> Updated: ${modifiedDate}</span>`);
            }
            if (fileSize) {
                formattedMeta.push(`<span class="meta-item"><span style="font-size: 10px;">üíæ</span> Size: ${fileSize}</span>`);
            }
            if (doc.status && doc.status !== 'Processing' && doc.status !== 'processing') {
                const statusIcon = doc.status === 'indexed' || doc.status === 'completed' ? '‚úÖ' : '‚è≥';
                formattedMeta.push(`<span class="meta-item"><span style="font-size: 10px;">${statusIcon}</span> ${doc.status}</span>`);
            }
            
            // Use enhanced icon function if available, fallback to existing
            const enhancedIcon = window.getFileTypeIcon ? window.getFileTypeIcon(displayName) : typeInfo;
            
            // Create document card with title above
            docDiv.style.cssText = 'border: 1px solid #e5e7eb; border-radius: 8px; background: #fafafa; padding: 12px; margin-bottom: 12px;';
            docDiv.innerHTML = `
                <div class="document-title" style="font-weight: 600; color: #1e293b; font-size: 16px; margin-bottom: 12px; line-height: 1.5; word-wrap: break-word;">${doc.title || 'Untitled Document'}</div>
                <div style="display: flex; gap: 12px; align-items: flex-start;">
                    <div class="doc-type-icon" style="position: relative; width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; border-radius: 8px; flex-shrink: 0; background: ${enhancedIcon.gradient || typeInfo.gradient};">
                        ${enhancedIcon.svg || (typeof typeInfo.icon === 'string' && typeInfo.icon.includes('<svg') ? typeInfo.icon : `<span style="color: white; font-size: 24px;">${typeInfo.icon}</span>`)}
                        ${doc.indexed ? '<div class="indexed-badge" style="position: absolute; top: -4px; right: -4px; width: 16px; height: 16px; background: #10b981; border: 2px solid white; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;">‚úì</div>' : ''}
                    </div>
                    <div class="document-info" style="flex: 1; min-width: 0; padding: 0 10px;">
                        <div class="document-filename" style="font-size: 12px; color: #64748b; margin-bottom: 4px;">
                            <strong>File:</strong> ${displayName}
                        </div>
                        <div class="document-meta" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 6px; font-size: 11px;">
                            ${metaItems.join('')}
                        </div>
                        ${doc.description ? `<div class="document-description" style="font-size: 11px; color: #94a3b8; line-height: 1.4;">${doc.description}</div>` : ''}
                    </div>
                    <div class="document-actions" style="display: flex; gap: 8px; align-items: center; flex-shrink: 0;">
                    <button class="action-btn btn-preview" onclick="previewDocument('${doc.id}', '${displayName}', '${fileExt}', null, event, '${doc.department || ''}')" style="padding: 6px 12px; background: white; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 12px; color: #374151;">
                        <span style="margin-right: 4px;">üëÅÔ∏è</span> Preview
                    </button>
                    <button class="action-btn btn-download" onclick="downloadDocument('${doc.id}', '${displayName}', '${doc.department || ''}')" style="padding: 6px 12px; background: white; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 12px; color: #374151;">
                        <span style="margin-right: 4px;">‚¨áÔ∏è</span> Download
                    </button>
                    <button class="btn-delete" onclick="deleteDocument('${doc.id}', '${doc.title || displayName}', event, '${doc.department || ''}', '${displayName}')" style="width: 32px; height: 32px; background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; cursor: pointer; color: #dc2626; display: flex; align-items: center; justify-content: center;" title="Delete document">
                        <span style="font-size: 16px;">üóëÔ∏è</span>
                    </button>
                </div>
                </div>
            `;
            
            return docDiv;
        }

        async function handleSearch() {
            const searchTerm = searchInput.value.trim();
            
            if (searchTerm.length < 2) {
                // If search term is too short, just reload current department
                loadDepartmentDocuments();
                return;
            }
            
            try {
                // Search across all documents using Azure Function
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        query: searchTerm,  // Changed from 'search' to 'query'
                        top: 50,
                        enableVector: false
                    })
                });
                
                if (response.ok) {
                    const searchResults = await response.json();
                    
                    // Clear current display
                    folderGrid.innerHTML = '';
                    
                    if (searchResults.value && searchResults.value.length > 0) {
                        // Deduplicate search results first
                        const uniqueDocsMap = new Map();
                        let allResults = searchResults.value;
                        
                        allResults.forEach(doc => {
                            let uniqueKey = '';
                            if (doc.fileName) {
                                uniqueKey = doc.fileName;
                            } else if (doc.title) {
                                uniqueKey = doc.title;
                            } else if (doc.id) {
                                const baseId = doc.id.replace(/_chunk\d+$/i, '').replace(/-chunk-\d+$/i, '').replace(/\.chunk\d+$/i, '');
                                uniqueKey = baseId;
                            }
                            
                            if (uniqueKey && !uniqueDocsMap.has(uniqueKey)) {
                                uniqueDocsMap.set(uniqueKey, doc);
                            }
                        });
                        
                        const uniqueResults = Array.from(uniqueDocsMap.values());
                        console.log(`Search: deduplicated ${allResults.length} chunks to ${uniqueResults.length} unique documents`);
                        
                        // Group search results by department
                        const groupedResults = {};
                        uniqueResults.forEach(doc => {
                            const dept = doc.department || 'General';
                            if (!groupedResults[dept]) {
                                groupedResults[dept] = [];
                            }
                            groupedResults[dept].push(doc);
                        });
                        
                        // Display grouped results
                        Object.keys(groupedResults).forEach(dept => {
                            const deptDiv = document.createElement('div');
                            deptDiv.className = 'search-results-group';
                            deptDiv.innerHTML = `<h3 style="margin: 10px 0; color: #1e293b;">${dept}</h3>`;
                            
                            groupedResults[dept].forEach(doc => {
                                const docItem = createDocumentItem({
                                    id: doc.id,
                                    title: doc.title || doc.fileName,
                                    fileName: doc.fileName,
                                    description: doc.description || '',
                                    lastModified: doc.uploadDate || doc.modifiedDate,  // Pass the raw date string
                                    uploadDate: doc.uploadDate,  // Add uploadDate field
                                    type: (doc.documentType || 'DOC').substring(0, 3).toUpperCase(),
                                    author: doc.author || 'SAX User',
                                    size: doc.size || doc.fileSize,
                                    version: doc.version || '1.0',
                                    department: doc.department,
                                    indexed: doc.indexed,
                                    vectorized: doc.vectorized,
                                    chunkCount: doc.chunkCount,
                                    isChunked: doc.isChunked
                                });
                                deptDiv.appendChild(docItem);
                            });
                            
                            folderGrid.appendChild(deptDiv);
                        });
                        
                        documentCount.textContent = `${uniqueResults.length} results found`;
                    } else {
                        folderGrid.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #64748b;">
                                <div style="font-size: 24px; margin-bottom: 12px;">üîç</div>
                                <div style="font-weight: 500; margin-bottom: 8px;">No Results Found</div>
                                <div style="font-size: 13px;">No documents match your search term "${searchTerm}"</div>
                            </div>
                        `;
                        documentCount.textContent = '0 results';
                    }
                }
            } catch (error) {
                console.error('Search failed:', error);
                folderGrid.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #dc2626;">
                        <div style="font-size: 24px; margin-bottom: 12px;">‚ö†Ô∏è</div>
                        <div style="font-weight: 500;">Search Error</div>
                        <div style="font-size: 13px;">Unable to search documents at this time</div>
                    </div>
                `;
            }
        }

        async function previewDocument(docId, fileName, fileType = 'pdf', fileSize = null, event = null, department = null) {
            // Prevent default action
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            console.log('Preview document:', docId, fileName, 'Department provided:', department);
            
            try {
                // Get the department - try multiple sources
                let actualDepartment = department;
                
                // If no department provided, try to get from current filter or fetch from API
                if (!actualDepartment || actualDepartment === '') {
                    // Try current department filter first
                    const departmentFilter = document.getElementById('departmentFilter');
                    if (departmentFilter && departmentFilter.value && departmentFilter.value !== '') {
                        actualDepartment = departmentFilter.value;
                        console.log('Using department from filter:', actualDepartment);
                    } else {
                        // Fetch from search API
                        console.log('Fetching document details to find department...');
                        const searchResponse = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-functions-key': API_CONFIG.functionKey
                            },
                            body: JSON.stringify({
                                query: `id:${docId}`,
                                top: 1
                            })
                        });
                        
                        if (searchResponse.ok) {
                            const searchData = await searchResponse.json();
                            if (searchData.value && searchData.value[0]) {
                                actualDepartment = searchData.value[0].department;
                                console.log('Department from API:', actualDepartment);
                            }
                        }
                    }
                }
                
                // Require department - no fallbacks
                if (!actualDepartment || actualDepartment === '') {
                    throw new Error('Cannot determine document department. Please select a department from the filter.');
                }
                
                const deptForPreview = actualDepartment;
                
                try {
                    const sasUrl = `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.generateSAS}?code=${API_CONFIG.functionKey}`;
                    const sasResponse = await fetch(sasUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: fileName,  // Use actual filename
                            department: deptForPreview,
                            containerName: 'saxdocuments',
                            expiryMinutes: 60
                        })
                    });
                    
                    if (sasResponse.ok) {
                        const sasData = await sasResponse.json();
                        if (sasData.sasUrl || sasData.blobUrl) {
                            // Show document in preview modal
                            showDocumentInModal(sasData.sasUrl || sasData.blobUrl, fileName, docId, actualDepartment);
                            return;
                        }
                    }
                } catch (sasError) {
                    console.log('SAS token generation failed, trying fallback:', sasError);
                }
                
                // First, try to get document details using Azure Function to find blob URL
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        search: `id:${docId}`,
                        select: 'id,blobUrl,fileUrl,storageUrl',
                        top: 1
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const doc = data.value && data.value[0] ? data.value[0] : null;
                    
                    // Check if we have a blob URL
                    if (doc && (doc.blobUrl || doc.fileUrl || doc.storageUrl)) {
                        const fileUrl = doc.blobUrl || doc.fileUrl || doc.storageUrl;
                        // Open the actual document in a new tab
                        window.open(fileUrl, '_blank');
                        return;
                    }
                }
                
                // If no blob URL found, try to construct one based on known patterns
                // Azure Blob Storage URL pattern: https://{account}.blob.core.windows.net/{container}/{path}
                const deptForUrl = currentDepartment || 'General';
                
                // Try constructing blob URL with actual filename
                const blobUrl = `https://saxtechmegamind.blob.core.windows.net/saxdocuments/${deptForUrl}/${fileName}`;  // Use actual filename
                
                // Show in modal instead of opening new window (which causes auto-download)
                showDocumentInModal(blobUrl, fileName, docId, department);
                
            } catch (error) {
                console.error('Preview error:', error);
                // Fallback: show alert with document info
                alert(`Document Preview\n\nFile: ${fileName}\nType: ${fileType.toUpperCase()}\nID: ${docId}\n\nNote: Unable to open document preview. Please try the Download button.`);
            }
        }
        
        async function downloadDocument(docId, fileName, department = null) {
            // Prevent default action
            event.preventDefault();
            event.stopPropagation();
            
            console.log('Download document:', docId, fileName, 'Department:', department);
            
            try {
                // First, get the document details to find the correct department
                let actualDepartment = department;
                if (!actualDepartment) {
                    const searchResponse = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-functions-key': API_CONFIG.functionKey
                        },
                        body: JSON.stringify({
                            query: `id:${docId}`,
                            top: 1
                        })
                    });
                    
                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.value && searchData.value[0]) {
                            actualDepartment = searchData.value[0].department;
                        }
                    }
                }
                
                // Use the actual department or fall back to 'Operations' if still not found
                const deptForDownload = actualDepartment || 'Operations';
                
                try {
                    const sasUrl = `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.generateSAS}?code=${API_CONFIG.functionKey}`;
                    const sasResponse = await fetch(sasUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: fileName,  // Use actual filename
                            department: deptForDownload,
                            containerName: 'saxdocuments',
                            expiryMinutes: 60
                        })
                    });
                    
                    if (sasResponse.ok) {
                        const sasData = await sasResponse.json();
                        
                        // Create a temporary link and trigger download
                        const link = document.createElement('a');
                        link.href = sasData.sasUrl || sasData.blobUrl;
                        link.download = fileName;  // Use actual filename for download
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        console.log(`Downloading with SAS token: ${fileName}`);
                        return;
                    }
                } catch (sasError) {
                    console.log('SAS token generation failed, trying fallback:', sasError);
                }
                
                // First, try to get document details using Azure Function to find blob URL
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        search: `id:${docId}`,
                        select: 'id,blobUrl,fileUrl,storageUrl',
                        top: 1
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const doc = data.value && data.value[0] ? data.value[0] : null;
                    
                    // Check if we have a blob URL
                    if (doc && (doc.blobUrl || doc.fileUrl || doc.storageUrl)) {
                        const fileUrl = doc.blobUrl || doc.fileUrl || doc.storageUrl;
                        
                        // Create a temporary link and trigger download
                        const link = document.createElement('a');
                        link.href = fileUrl;
                        link.download = fileName;  // Use actual filename for download
                        link.target = '_blank';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        console.log(`Downloading from blob: ${fileName}`);
                        return;
                    }
                }
                
                // Fallback: Try Azure Function endpoint
                const downloadUrl = `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.downloadDocument}?id=${docId}`;
                const urlWithAuth = `${downloadUrl}&code=${API_CONFIG.functionKey}`;
                
                // Create a temporary link and trigger download
                const link = document.createElement('a');
                link.href = urlWithAuth;
                link.download = fileName;  // Use actual filename for download
                link.target = '_blank';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(`Downloading via function: ${fileName}`);
                
            } catch (error) {
                console.error('Download error:', error);
                alert(`Unable to download document "${fileName}". Please try again later.`);
            }
        }
        
        // Store current preview data for download button
        let currentPreviewData = null;
        
        function showDocumentInModal(url, fileName, docId, department) {
            // First try to use the enhanced preview system if available
            if (window.openDocumentPreview && typeof window.openDocumentPreview === 'function') {
                console.log('Using enhanced preview system');
                window.openDocumentPreview(fileName, department);
                return;
            }
            
            // Fall back to inline modal preview
            const modal = document.getElementById('previewModal');
            const title = document.getElementById('previewTitle');
            const content = document.getElementById('previewContent');
            const info = document.getElementById('previewInfo');
            
            // Store data for download button and new tab
            currentPreviewData = { docId, fileName, department, url };
            
            // Update title
            title.textContent = fileName;
            
            // Clear previous content
            content.innerHTML = '';
            
            // Determine file type
            const fileExt = fileName.split('.').pop().toLowerCase();
            const fileTypeInfo = getFileTypeInfo(fileExt);
            
            // Update info
            if (info) {
                info.innerHTML = `${fileTypeInfo.name} ‚Ä¢ ${fileExt.toUpperCase()}`;
            }
            
            if (fileExt === 'pdf') {
                // For PDFs, use iframe to display directly
                const iframe = document.createElement('iframe');
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.background = 'white';
                
                // Add the PDF URL directly to iframe
                // Most modern browsers will display PDFs inline
                iframe.src = url;
                
                content.appendChild(iframe);
                
                // Add a small note at the bottom
                const note = document.createElement('div');
                note.style.cssText = `
                    position: absolute;
                    bottom: 10px;
                    right: 10px;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 11px;
                    z-index: 1000;
                `;
                note.innerHTML = `PDF Viewer ‚Ä¢ <button onclick="openInNewTab()" style="background: transparent; color: #60a5fa; border: none; padding: 0; margin: 0 4px; cursor: pointer; text-decoration: underline;">Open in New Tab</button>`;
                content.appendChild(note);
            } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg'].includes(fileExt)) {
                // For images, display directly
                const img = document.createElement('img');
                img.src = url;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '100%';
                img.style.objectFit = 'contain';
                content.appendChild(img);
            } else if (['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(fileExt)) {
                // For Office documents, use iframe with Office Online viewer or direct URL
                const iframe = document.createElement('iframe');
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.background = 'white';
                
                // Try Office Online viewer first (works for public URLs)
                // For private URLs, this might not work but we'll try anyway
                const viewerUrl = `https://view.officeapps.live.com/op/embed.aspx?src=${encodeURIComponent(url)}`;
                iframe.src = viewerUrl;
                
                content.appendChild(iframe);
                
                // Add fallback message that appears briefly
                const fallbackMsg = document.createElement('div');
                fallbackMsg.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 12px;
                    z-index: 1000;
                `;
                fallbackMsg.innerHTML = `If document doesn't load, click <button onclick="openInNewTab()" style="background: #3b82f6; color: white; border: none; padding: 2px 8px; border-radius: 4px; margin: 0 4px; cursor: pointer;">Open in New Tab</button> or <button onclick="downloadFromPreview()" style="background: #10b981; color: white; border: none; padding: 2px 8px; border-radius: 4px; margin: 0 4px; cursor: pointer;">Download</button>`;
                content.appendChild(fallbackMsg);
                
                // Hide message after 5 seconds
                setTimeout(() => {
                    if (fallbackMsg.parentNode) {
                        fallbackMsg.style.transition = 'opacity 0.5s';
                        fallbackMsg.style.opacity = '0';
                        setTimeout(() => fallbackMsg.remove(), 500);
                    }
                }, 5000);
            } else if (['txt', 'csv', 'json', 'xml', 'md'].includes(fileExt)) {
                // For text files, fetch and display content
                fetch(url)
                    .then(response => response.text())
                    .then(text => {
                        const pre = document.createElement('pre');
                        pre.style.padding = '20px';
                        pre.style.margin = '0';
                        pre.style.fontFamily = 'monospace';
                        pre.style.fontSize = '14px';
                        pre.style.lineHeight = '1.5';
                        pre.style.whiteSpace = 'pre-wrap';
                        pre.style.wordWrap = 'break-word';
                        pre.textContent = text;
                        content.appendChild(pre);
                    })
                    .catch(error => {
                        content.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <p style="color: #dc2626; margin-bottom: 10px;">Unable to load preview</p>
                                <p style="color: #6b7280; font-size: 14px;">Click Download to save the file locally.</p>
                            </div>
                        `;
                    });
            } else {
                // For unknown types, show a message
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 20px;">üìÑ</div>
                        <p style="color: #374151; margin-bottom: 10px; font-weight: 500;">${fileName}</p>
                        <p style="color: #6b7280; font-size: 14px;">Preview not available for this file type.</p>
                        <p style="color: #6b7280; font-size: 14px; margin-top: 20px;">Click Download to save the file locally.</p>
                    </div>
                `;
            }
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closePreviewModal() {
            const modal = document.getElementById('previewModal');
            const content = document.getElementById('previewContent');
            
            // Clear content
            content.innerHTML = '';
            
            // Hide modal
            modal.style.display = 'none';
            
            // Clear stored data
            currentPreviewData = null;
        }
        
        function openInNewTab() {
            if (currentPreviewData && currentPreviewData.url) {
                window.open(currentPreviewData.url, '_blank');
            }
        }
        
        function downloadFromPreview() {
            if (currentPreviewData) {
                downloadDocument(currentPreviewData.docId, currentPreviewData.fileName, currentPreviewData.department);
            }
        }
        
        function getAppForFileType(ext) {
            const apps = {
                'doc': 'Microsoft Word',
                'docx': 'Microsoft Word',
                'xls': 'Microsoft Excel',
                'xlsx': 'Microsoft Excel',
                'ppt': 'Microsoft PowerPoint',
                'pptx': 'Microsoft PowerPoint',
                'pdf': 'Adobe Acrobat',
                'txt': 'Text Editor',
                'csv': 'Excel or Text Editor'
            };
            return apps[ext] || 'the appropriate application';
        }
        
        function showPDFViewer(docId, title) {
            // Legacy function - now handled by showDocumentInModal
            console.log('Legacy showPDFViewer called');
        }
        
        // Helper function to get file type info with brand icons
        function getFileTypeInfo(ext) {
            const types = {
                // Adobe PDF
                'pdf': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M10,19H8V15H9.5C10.3,15 11,15.7 11,16.5C11,17.3 10.3,18 9.5,18H10V19M9.5,17H9V16H9.5C9.8,16 10,16.2 10,16.5C10,16.8 9.8,17 9.5,17M14,19H12V15H14A2,2 0 0,1 16,17A2,2 0 0,1 14,19M14,16H13V18H14C14.5,18 15,17.5 15,17C15,16.5 14.5,16 14,16Z"/></svg>`, 
                    class: 'pdf', 
                    gradient: 'linear-gradient(135deg, #ee3e38 0%, #c4302b 100%)',
                    name: 'PDF Document'
                },
                // Microsoft Word
                'doc': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M17,12L14,15V13H10V11H14V9L17,12Z"/></svg>`, 
                    class: 'word', 
                    gradient: 'linear-gradient(135deg, #2b579a 0%, #1e3a6f 100%)',
                    name: 'Word Document'
                },
                'docx': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M17,12L14,15V13H10V11H14V9L17,12Z"/></svg>`, 
                    class: 'word', 
                    gradient: 'linear-gradient(135deg, #2b579a 0%, #1e3a6f 100%)',
                    name: 'Word Document'
                },
                // Microsoft Excel
                'xls': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M8,15.5H16V17H8V15.5M8,12.5H16V14H8V12.5Z"/></svg>`, 
                    class: 'excel', 
                    gradient: 'linear-gradient(135deg, #217346 0%, #185c37 100%)',
                    name: 'Excel Spreadsheet'
                },
                'xlsx': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M8,15.5H16V17H8V15.5M8,12.5H16V14H8V12.5Z"/></svg>`, 
                    class: 'excel', 
                    gradient: 'linear-gradient(135deg, #217346 0%, #185c37 100%)',
                    name: 'Excel Spreadsheet'
                },
                // Microsoft PowerPoint
                'ppt': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M8,11H16V13H8V11M8,14H16V16H8V14M8,17H12V19H8V17Z"/></svg>`, 
                    class: 'powerpoint', 
                    gradient: 'linear-gradient(135deg, #d24726 0%, #b92b15 100%)',
                    name: 'PowerPoint Presentation'
                },
                'pptx': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M8,11H16V13H8V11M8,14H16V16H8V14M8,17H12V19H8V17Z"/></svg>`, 
                    class: 'powerpoint', 
                    gradient: 'linear-gradient(135deg, #d24726 0%, #b92b15 100%)',
                    name: 'PowerPoint Presentation'
                },
                // Text files
                'txt': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M8,12H16V14H8V12M8,16H13V18H8V16Z"/></svg>`, 
                    class: 'text', 
                    gradient: 'linear-gradient(135deg, #64748b 0%, #475569 100%)',
                    name: 'Text Document'
                },
                'csv': { 
                    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M8,15.5H16V17H8V15.5M8,12.5H16V14H8V12.5Z"/></svg>`, 
                    class: 'csv', 
                    gradient: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)',
                    name: 'CSV File'
                },
                // Images
                'jpg': { icon: 'üñºÔ∏è', class: 'image', gradient: 'linear-gradient(135deg, #a333c8 0%, #9627ba 100%)', name: 'JPEG Image' },
                'jpeg': { icon: 'üñºÔ∏è', class: 'image', gradient: 'linear-gradient(135deg, #a333c8 0%, #9627ba 100%)', name: 'JPEG Image' },
                'png': { icon: 'üñºÔ∏è', class: 'image', gradient: 'linear-gradient(135deg, #a333c8 0%, #9627ba 100%)', name: 'PNG Image' },
                'gif': { icon: 'üñºÔ∏è', class: 'image', gradient: 'linear-gradient(135deg, #a333c8 0%, #9627ba 100%)', name: 'GIF Image' },
                'bmp': { icon: 'üñºÔ∏è', class: 'image', gradient: 'linear-gradient(135deg, #a333c8 0%, #9627ba 100%)', name: 'Bitmap Image' }
            };
            
            return types[ext] || { 
                icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>`, 
                class: 'unknown', 
                gradient: 'linear-gradient(135deg, #767676 0%, #616161 100%)',
                name: 'Document'
            };
        }
        
        // Helper function to format date to EST timezone
        function formatDateToEST(dateString) {
            if (!dateString) return '--';
            
            try {
                const date = new Date(dateString);
                
                // Format to EST/EDT (Eastern Time)
                const options = {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                };
                
                const formatter = new Intl.DateTimeFormat('en-US', options);
                const formatted = formatter.format(date);
                
                // Add EST/EDT label
                const isDST = date.getMonth() >= 2 && date.getMonth() <= 10; // Rough DST check
                const timezone = isDST ? 'EDT' : 'EST';
                
                return `${formatted} ${timezone}`;
            } catch (error) {
                console.error('Error formatting date:', error);
                return dateString; // Return original if formatting fails
            }
        }
        
        // Helper function to format file size
        function formatFileSize(bytes) {
            if (!bytes || bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Load departments from localStorage (shared with admin page)
        function loadDepartmentsFromLocalStorage() {
            const savedDepts = localStorage.getItem('megamind_departments');
            if (savedDepts) {
                try {
                    const departments = JSON.parse(savedDepts);
                    updateDepartmentDropdowns(departments.map(d => d.name));
                } catch (error) {
                    console.error('Error parsing departments:', error);
                }
            }
        }
        
        // Load departments from Azure Storage/Index
        async function loadDepartmentsFromAzure() {
            try {
                // Call the index maintenance function to get departments
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.indexMaintenance}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        operation: 'list-departments'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.departments) {
                        // Don't update dropdowns - use hardcoded departments only
                        // updateDepartmentDropdowns(data.departments);
                        console.log('Departments from Azure:', data.departments);
                    }
                } else {
                    console.log('Could not load departments from Azure, using defaults');
                }
            } catch (error) {
                console.error('Error loading departments:', error);
                // Use default departments if Azure load fails
            }
        }
        
        // Update department dropdowns with dynamic data
        function updateDepartmentDropdowns(departments) {
            const departmentSelect = document.getElementById('department');
            const departmentFilter = document.getElementById('departmentFilter');
            
            if (departmentSelect) {
                // Save current selection
                const currentValue = departmentSelect.value;
                
                // Clear ALL existing options
                departmentSelect.innerHTML = '<option value="">Select Department</option>';
                
                // Add departments from localStorage
                departments.forEach(dept => {
                    if (dept && dept !== 'converted-documents' && dept !== 'original-documents') {
                        const option = document.createElement('option');
                        option.value = dept;
                        option.textContent = dept;
                        departmentSelect.appendChild(option);
                    }
                });
                
                // Restore selection if it still exists
                if (currentValue && Array.from(departmentSelect.options).some(opt => opt.value === currentValue)) {
                    departmentSelect.value = currentValue;
                }
            }
            
            if (departmentFilter) {
                // Save current selection
                const currentValue = departmentFilter.value;
                
                // Clear ALL existing options
                departmentFilter.innerHTML = '<option value="">All Departments</option>';
                
                // Add departments from localStorage
                departments.forEach(dept => {
                    if (dept && dept !== 'converted-documents' && dept !== 'original-documents') {
                        const option = document.createElement('option');
                        option.value = dept;
                        option.textContent = dept;
                        departmentFilter.appendChild(option);
                    }
                });
                
                // Restore selection if it still exists
                if (currentValue && Array.from(departmentFilter.options).some(opt => opt.value === currentValue)) {
                    departmentFilter.value = currentValue;
                }
            }
        }
        
        // Utility: list of indexes (editable via Admin; fallback defaults)
        function getConfiguredIndexes() {
            try {
                const saved = localStorage.getItem('megamind_indexes');
                if (saved) {
                    const list = JSON.parse(saved);
                    if (Array.isArray(list) && list.length) return list;
                }
            } catch {}
            // Fallback: keep sop-documents plus audit-tax-documents and other placeholders until admin config sets real ones
            return [
                { name: 'sop-documents', label: 'sop-documents' },
                { name: 'ld-documents', label: 'ld-documents' },
                { name: 'ustaxpublic', label: 'ustaxpublic' },
                { name: 'audit-tax-documents', label: 'audit-tax-documents' }
            ];
        }

        // Render header cards for each index and populate stats
        async function loadAllIndexStatistics() {
            const indexes = getConfiguredIndexes();
            const container = document.getElementById('indexesHeaderStats');
            if (!container) return;

            // Clear all except the first fallback card markup
            container.innerHTML = '';

            // Create a card per index (compact, clean layout)
            indexes.forEach((idx) => {
                const card = document.createElement('div');
                card.className = 'index-card';
                card.setAttribute('data-index', idx.name);
                card.style.cssText = 'min-width: 230px; padding:10px 12px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px;';
                card.innerHTML = `
                    <div style="font-size: 11px; color:#cbd5e1; text-transform: uppercase; letter-spacing:.4px; margin-bottom:6px;">${idx.label || idx.name}</div>
                    <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; align-items:center;">
                        <div style="text-align:center;">
                            <div id="docCount-${idx.name}" style="font-size:16px; font-weight:700; color:#FFD700;">0</div>
                            <div style="font-size:9px; opacity:.8; text-transform:uppercase;">Documents</div>
                        </div>
                        <div style="text-align:center;">
                            <div id="indexSize-${idx.name}" style="font-size:16px; font-weight:700; color:#FFD700;">0 MB</div>
                            <div style="font-size:9px; opacity:.8; text-transform:uppercase;">Index Size</div>
                        </div>
                        <div style="text-align:center;">
                            <div id="lastUpdate-${idx.name}" style="font-size:16px; font-weight:700; color:#FFD700;">--</div>
                            <div style="font-size:9px; opacity:.8; text-transform:uppercase;">Last Update</div>
                        </div>
                        <div style="text-align:center;">
                            <div id="vectorized-${idx.name}" style="font-size:16px; font-weight:700; color:#FFD700;">0</div>
                            <div style="font-size:9px; opacity:.8; text-transform:uppercase;">Vectorized</div>
                        </div>
                    </div>`;
                container.appendChild(card);
            });

            // Populate stats for each index using the documents/search function which accepts indexName
            for (const idx of indexes) {
                try {
                    // Always use server-side proxies to avoid CORS and keep api-key off the client
                    let totalDocs = 0;

                    // Count via same-origin API to avoid CORS and ensure indexName honored
                    try {
const countResp = await fetch(`/api/documents-search/${idx.name}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ search: '*', top: 0 })
                    });
                        if (countResp.ok) {
                            const countData = await countResp.json();
                            totalDocs = countData['@odata.count'] || (countData.value ? countData.value.length : 0) || 0;
                        } else {
                            // Fallback to Function App
                            const fb = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'x-functions-key': API_CONFIG.functionKey
                                },
                                body: JSON.stringify({ search: '*', top: 0, indexName: idx.name })
                            });
                            if (fb.ok) {
                                const countData = await fb.json();
                                totalDocs = countData['@odata.count'] || (countData.value ? countData.value.length : 0) || 0;
                            }
                        }
                    } catch (e) { /* ignore */ }

                    const docEl = document.getElementById(`docCount-${idx.name}`);
                    if (docEl) docEl.textContent = totalDocs.toLocaleString();

                    // Estimate size and vectorized per index
                    const sizeMB = (totalDocs * 50 / 1024).toFixed(1);
                    const sizeEl = document.getElementById(`indexSize-${idx.name}`);
                    if (sizeEl) sizeEl.textContent = `${sizeMB} MB`;
                    const vecEl = document.getElementById(`vectorized-${idx.name}`);
                    if (vecEl) vecEl.textContent = Math.floor(totalDocs * 0.8).toLocaleString();

// 3) Find last update - use Function App consistently for ALL indexes to avoid CORS issues
try {
    const fbLatest = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-functions-key': API_CONFIG.functionKey
        },
        body: JSON.stringify({ 
            search: '*', 
            top: 1, 
            indexName: idx.name,
            orderby: 'metadata_storage_last_modified desc',
            select: 'metadata_storage_last_modified,uploadDate,createdDate,modifiedDate,lastModified'
        })
    });
    
    if (fbLatest.ok) {
        const latest = await fbLatest.json();
        const docs = latest.value || latest.results || [];
        const target = document.getElementById(`lastUpdate-${idx.name}`);
        
        if (target) {
            if (docs.length > 0) {
                // Find the most recent date from all available date fields
                let mostRecentDate = null;
                const dateFields = ['metadata_storage_last_modified', 'uploadDate', 'createdDate', 'modifiedDate', 'lastModified'];
                
                docs.forEach(doc => {
                    dateFields.forEach(field => {
                        if (doc[field]) {
                            const date = new Date(doc[field]);
                            if (!mostRecentDate || date > mostRecentDate) {
                                mostRecentDate = date;
                            }
                        }
                    });
                });
                
                if (mostRecentDate) {
                    const opts = { timeZone: 'America/New_York', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: true };
                    target.textContent = new Intl.DateTimeFormat('en-US', opts).format(mostRecentDate);
                } else {
                    target.textContent = 'No date info';
                }
            } else {
                target.textContent = 'No docs';
            }
        }
    } else {
        console.warn('Function App search failed for', idx.name, 'Status:', fbLatest.status);
        const target = document.getElementById(`lastUpdate-${idx.name}`);
        if (target) target.textContent = 'Error';
    }
} catch (e) {
    console.warn('Function App query failed for', idx.name, e);
    const target = document.getElementById(`lastUpdate-${idx.name}`);
    if (target) target.textContent = 'Error';
}
                } catch (e) {
                    console.warn('Failed index stats for', idx.name, e);
                }
            } // Close for loop
        } // Close loadAllIndexStatistics function

        // Legacy single-index stats (kept for backward compatibility but no longer used)
        async function loadIndexStatistics() {
            try {
                // First get document count
                const statsResponse = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.indexMaintenance}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        operation: 'stats'
                    })
                });
                
                let totalDocs = 0;
                if (statsResponse.ok) {
                    const data = await statsResponse.json();
                    totalDocs = data.stats?.totalDocuments || 0;
                    
                    // Update statistics in header
                    document.getElementById('totalDocCount').textContent = totalDocs.toLocaleString();
                    
                    // Estimate index size (rough calculation based on doc count)
                    const avgDocSize = 50; // KB average
                    const totalSizeMB = (totalDocs * avgDocSize / 1024).toFixed(1);
                    document.getElementById('totalIndexSize').textContent = `${totalSizeMB} MB`;
                    
                    // Estimate vectorized count (for now, assume 80% are vectorized)
                    const vectorized = Math.floor(totalDocs * 0.8);
                    document.getElementById('vectorizedCount').textContent = vectorized.toLocaleString();
                }
                
                // Now query for the most recent document to get actual last update time
                const searchResponse = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                        body: JSON.stringify({
                        query: '*',
                        top: 10,
                        orderby: 'uploadDate desc',
                        select: 'uploadDate,createdDate,lastModified'
                    })
                });
                
                if (searchResponse.ok) {
                    const searchData = await searchResponse.json();
                    const documents = searchData.value || searchData.results || [];
                    
                    if (documents && documents.length > 0) {
                        // Find the most recent date from the documents
                        let mostRecentDate = null;
                        documents.forEach(doc => {
                            const dates = [doc.uploadDate, doc.createdDate, doc.modifiedDate].filter(d => d);
                            dates.forEach(dateStr => {
                                const date = new Date(dateStr);
                                if (!mostRecentDate || date > mostRecentDate) {
                                    mostRecentDate = date;
                                }
                            });
                        });
                        
                        if (mostRecentDate) {
                            // Format to EST - just show date and time, no full timestamp
                            const options = {
                                timeZone: 'America/New_York',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: true
                            };
                            const formatter = new Intl.DateTimeFormat('en-US', options);
                            const formatted = formatter.format(mostRecentDate);
                            document.getElementById('lastIndexUpdate').textContent = formatted;
                        } else {
                            document.getElementById('lastIndexUpdate').textContent = '--';
                        }
                    } else {
                        document.getElementById('lastIndexUpdate').textContent = '--';
                    }
                }
            } catch (error) {
                console.error('Failed to load index statistics:', error);
                document.getElementById('lastIndexUpdate').textContent = '--';
            }
        }
        
        // Delete document function - deletes ALL chunks of a document
        async function deleteDocument(docId, title, event, department = null, fileName = null) {
            // Prevent default action
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Extract base document ID (without chunk suffix)
            const baseDocId = docId.split('_chunk_')[0];
            const baseFileName = fileName ? fileName.split('_chunk_')[0] : null;
            
            // Confirm deletion
            if (!confirm(`Are you sure you want to delete ALL chunks of "${title}"?\n\nThis will remove the entire document (all chunks) from both the repository and cloud storage.`)) {
                return;
            }
            
            try {
                console.log(`Attempting to delete ALL chunks of document: ${baseDocId} (${title})`);
                console.log(`Department: ${department}, Base FileName: ${baseFileName}`);
                
                // Collect all chunk IDs to delete from index
                let chunkIdsToDelete = [];
                let blobsDeleted = 0;
                
                // Try to delete all blob chunks from storage
                if (department && fileName) {
                    try {
                        console.log('Attempting to delete document using find-by-file API');
                        const deleteBlobUrl = `${API_CONFIG.baseUrl}/DeleteBlob?code=${API_CONFIG.functionKey}`;
                        
                        // Use the new find-by-file API for better document identification
                        const findByFileUrl = `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.findByFile}`;
                        const findResponse = await fetch(findByFileUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-functions-key': API_CONFIG.functionKey
                            },
                            body: JSON.stringify({
                                fileName: baseFileName || fileName,
                                department: department
                            })
                        });
                        
                        let chunksToDelete = [];
                        if (findResponse.ok) {
                            const findData = await findResponse.json();
                            const docs = findData.results || [];
                            
                            console.log(`Found ${docs.length} documents matching filename for deletion`);
                            
                            // Collect all document IDs and filenames for deletion
                            docs.forEach(doc => {
                                if (doc.id) chunkIdsToDelete.push(doc.id);
                                if (doc.fileName) {
                                    chunksToDelete.push({
                                        id: doc.id,
                                        fileName: doc.fileName
                                    });
                                }
                            });
                        } else {
                            console.warn('Find-by-file API failed, falling back to document ID');
                            chunkIdsToDelete.push(docId);
                        }
                        
                        // Delete all found chunks from blob storage
                        for (const chunkInfo of chunksToDelete) {
                            const chunkFileName = chunkInfo.fileName;
                            
                            try {
                                const blobResponse = await fetch(deleteBlobUrl, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'x-functions-key': API_CONFIG.functionKey
                                    },
                                    body: JSON.stringify({
                                        fileName: chunkFileName,
                                        department: department,
                                        containerName: 'saxdocuments'
                                    })
                                });
                                
                                if (blobResponse.ok) {
                                    const blobResult = await blobResponse.json();
                                    console.log(`Blob chunk deleted:`, chunkFileName);
                                    blobsDeleted++;
                                } else {
                                    console.warn(`Failed to delete blob: ${chunkFileName}`);
                                }
                            } catch (error) {
                                console.error(`Error deleting blob ${chunkFileName}:`, error);
                            }
                        }
                        
                        if (blobsDeleted > 0) {
                            console.log(`Successfully deleted ${blobsDeleted} blob chunk(s)`);
                        }
                    } catch (blobError) {
                        console.error('Error during blob deletion:', blobError);
                        // Continue with index deletion even if blob deletion fails
                        // Add the base document ID at minimum
                        chunkIdsToDelete.push(docId);
                    }
                } else {
                    // No blob info, just delete the provided docId from index
                    chunkIdsToDelete.push(docId);
                }
                
                // Now delete all chunks from search index using Azure Function
                console.log(`Deleting ${chunkIdsToDelete.length} document chunk(s) from search index`);
                const batchDeleteUrl = `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.deleteDocument}`;
                
                const functionResponse = await fetch(batchDeleteUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        documentIds: chunkIdsToDelete,
                        // Include info for all chunks
                        documents: chunkIdsToDelete.map((chunkId, index) => {
                            const chunkSuffix = index === 0 ? '' : `_chunk_${index}`;
                            const chunkFileName = baseFileName ? 
                                baseFileName + chunkSuffix + (fileName && fileName.includes('.') ? 
                                fileName.substring(fileName.lastIndexOf('.')) : '') : '';
                            return {
                                id: chunkId,
                                department: department || '',
                                fileName: chunkFileName || '',
                                blobPath: department && chunkFileName ? `${department}/${chunkFileName}` : ''
                            };
                        })
                    })
                });
                
                console.log('Delete response status:', functionResponse.status);
                
                if (functionResponse.ok) {
                    const result = await functionResponse.json();
                    console.log('Delete result:', result);
                    
                    // Check if deletion was successful
                    if (result.success && result.totalDeleted > 0) {
                        console.log(`Successfully deleted ${result.totalDeleted} document chunk(s) from index`);
                    } else if (result.results && result.results.length > 0) {
                        // Only check individual results if overall success is false
                        const failed = result.results.filter(r => !r.success);
                        if (failed.length > 0 && !result.success) {
                            console.warn('Some chunk deletions failed:', failed);
                            throw new Error(`Failed to delete all chunks: ${failed[0].message || 'Unknown error'}`);
                        }
                    }
                    
                    // Show success message with cleaner notification
                    const totalDeleted = result.totalDeleted || chunkIdsToDelete.length;
                    const chunkText = totalDeleted > 1 ? `${totalDeleted} chunks` : '1 document';
                    const successDiv = document.createElement('div');
                    successDiv.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #10b981;
                        color: white;
                        padding: 12px 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        z-index: 10000;
                        animation: slideIn 0.3s ease-out;
                    `;
                    successDiv.innerHTML = `‚úì Document "${title}" (${chunkText}) deleted successfully. Refreshing...`;
                    document.body.appendChild(successDiv);
                    
                    // Refresh the entire page after a short delay to ensure everything is updated
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    const errorData = await functionResponse.text();
                    console.error('Delete failed with response:', errorData);
                    throw new Error(`Delete failed: ${functionResponse.status} - ${errorData}`);
                }
            } catch (error) {
                console.error('Delete error:', error);
                
                // Show error message with cleaner notification
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #ef4444;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                `;
                errorDiv.innerHTML = `‚úó Failed to delete document: ${error.message}`;
                document.body.appendChild(errorDiv);
                
                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }
        }

        // Removed duplicate downloadDocument function

        function handleUpdateTypeChange() {
            const updateType = updateTypeSelect.value;
            
            if (updateType === 'update') {
                existingSOPsDiv.classList.remove('hidden');
                additionalInfoDiv.classList.add('additional-info');
                loadExistingSOPs();
            } else if (updateType === 'new') {
                existingSOPsDiv.classList.add('hidden');
                additionalInfoDiv.classList.remove('additional-info');
                additionalInfoDiv.style.display = 'block';
                document.getElementById('sopTitle').required = true;
            } else {
                existingSOPsDiv.classList.add('hidden');
                additionalInfoDiv.style.display = 'none';
                document.getElementById('sopTitle').required = false;
            }
        }

        function loadExistingSOPs() {
            const dept = departmentSelect.value;
            const sopType = sopTypeSelect.value;
            const updateType = updateTypeSelect.value;

            if (updateType === 'update' && dept && sopType) {
                // Call Azure Function to get existing SOPs for this department/type
                fetchExistingSOPs(dept, sopType)
                    .then(sops => {
                        displaySOPs(sops);
                    })
                    .catch(error => {
                        console.error('Error loading existing SOPs:', error);
                        displaySOPs([]);
                    });
            }
        }

        async function fetchExistingSOPs(department, sopType) {
            try {
                // Query documents using Azure Function with correct format
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.search}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify({
                        query: '*',  // Use 'query' not 'search'
                        department: department || '',  // Direct department field
                        documentType: sopType || '',  // Direct documentType field
                        page: 1,
                        pageSize: 50,
                        useVectorSearch: false  // Explicitly disable vector search
                    })
                });

                if (!response.ok) {
                    throw new Error(`Search API HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                // Azure AI Search returns results in 'value' array
                return data.value ? data.value.map(doc => ({
                    id: doc.id,
                    title: doc.title || doc.fileName,
                    lastModified: doc.uploadDate ? new Date(doc.uploadDate).toLocaleDateString() : 'Unknown'
                })) : [];
            } catch (error) {
                console.error('Document search failed:', error);
                return [];
            }
        }

        function displaySOPs(sops) {
            sopList.innerHTML = '';
            
            if (!sops || sops.length === 0) {
                sopList.innerHTML = '<div class="sop-item" style="color: #64748b;">No existing documents found</div>';
                return;
            }

            sops.forEach(sop => {
                const sopItem = document.createElement('div');
                sopItem.className = 'sop-item';
                sopItem.innerHTML = `
                    <div style="font-weight: 500;">${sop.title}</div>
                    <div style="font-size: 11px; color: #64748b; margin-top: 2px;">Modified: ${sop.lastModified || 'Unknown'}</div>
                `;
                sopItem.addEventListener('click', () => selectSOP(sop, sopItem));
                sopList.appendChild(sopItem);
            });
        }

        function selectSOP(sop, element) {
            document.querySelectorAll('.sop-item').forEach(item => item.classList.remove('selected'));
            element.classList.add('selected');
            selectedSOPIdInput.value = sop.id;
            additionalInfoDiv.style.display = 'block';
            additionalInfoDiv.classList.remove('additional-info');
            document.getElementById('sopTitle').value = sop.title;
            document.getElementById('sopTitle').required = false;
        }

        function handleDragOver(e) {
            e.preventDefault();
            fileUploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                displaySelectedFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                displaySelectedFile(file);
            }
        }

        function displaySelectedFile(file) {
            const fileSize = formatFileSize(file.size);
            fileName.textContent = `${file.name} (${fileSize})`;
            selectedFileDiv.style.display = 'block';
            fileUploadArea.style.display = 'none';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function handleFormSubmit(e) {
            e.preventDefault();
            
            if (!validateForm()) {
                return;
            }

            // Show upload modal
            showUploadModal();
            updateUploadProgress('hash', 'Calculating document hash...');
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Processing...';
            progressBar.style.display = 'block';

            // Prepare form data for Azure Function
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            formData.append('department', departmentSelect.value);
            formData.append('sopType', sopTypeSelect.value);
            formData.append('updateType', updateTypeSelect.value);
            formData.append('title', document.getElementById('sopTitle').value || '');
            formData.append('description', document.getElementById('sopDescription').value || '');
            formData.append('keywords', document.getElementById('keywords').value || '');
            formData.append('version', document.getElementById('version').value || '1.0');
            
            if (updateTypeSelect.value === 'update') {
                formData.append('existingDocId', selectedSOPIdInput.value);
            }
            
            // Cache the file and form data for retry functionality
            window.lastUploadedFile = fileInput.files[0];
            window.lastUploadFormData = formData;
            console.log('Cached upload data for retry:', {
                fileName: window.lastUploadedFile.name,
                formDataKeys: Array.from(formData.keys())
            });

            // Upload directly to Azure Function with enhanced chunking support
            uploadDocumentToAzure(formData)
                .then(response => {
                    updateUploadProgress('complete', 'Upload Complete!', 'Your document has been successfully processed');
                    completeUpload();
                    // Don't close the modal automatically - let user decide
                    // Modal will show completion status with buttons to refresh or close
                })
                .catch(error => {
                    console.error('Upload failed:', error);
                    console.error('Error message:', error.message);
                    
                    // Only show error if it hasn't been shown already by the upload function
                    if (!window.isErrorDisplayed) {
                        const errorMessage = error.message === 'Upload failed - see modal for details' 
                            ? 'Upload failed due to server error - check console for details'
                            : (error.message || 'An error occurred during upload');
                        
                        showUploadError(errorMessage);
                    }
                    
                    // Always call the generic error handler for additional cleanup
                    handleUploadError(error);
                });
        }

        // New Azure Function upload with enhanced chunking
        async function uploadDocumentToAzure(formData) {
            try {
                const file = formData.get('file');
                
                // Validate file exists
                if (!file || file.size === 0) {
                    throw new Error('No file selected or file is empty');
                }
                
                console.log('File details:', {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    sizeMB: (file.size / (1024 * 1024)).toFixed(2)
                });
                
                // Convert file to base64
                const fileContent = await fileToBase64(file);
                
                // Validate base64 content
                if (!fileContent || fileContent.length === 0) {
                    throw new Error('Failed to convert file to base64');
                }
                
                console.log('Base64 content generated, length:', fileContent.length);
                
                // Create the JSON payload for the enhanced Azure Function
                const azurePayload = {
                    fileName: file.name,
                    fileContent: fileContent,
                    mimeType: file.type || 'application/octet-stream',
                    department: formData.get('department') || 'IT',
                    sopType: formData.get('sopType') || 'Process Documentation',
                    documentType: formData.get('sopType') || 'Process Documentation',
                    updateType: (formData.get('updateType') || 'new').charAt(0).toUpperCase() + (formData.get('updateType') || 'new').slice(1),
                    title: formData.get('title') || file.name.split('.')[0],
                    description: formData.get('description') || '',
                    keywords: formData.get('keywords') || '',
                    version: formData.get('version') || '1.0',
                    existingDocId: formData.get('existingDocId') || ''
                };
                
                console.log('Uploading to enhanced Azure Function...');
                
                // Update progress to uploading
                if (window.updateUploadProgress) {
                    window.updateUploadProgress('upload', 'Uploading and processing with chunking...');
                }
                
                // Upload to enhanced Azure Function endpoint
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.uploadDocument}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': API_CONFIG.functionKey
                    },
                    body: JSON.stringify(azurePayload)
                });
                
                // Handle response
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Azure Function error response:', errorText);
                    
                    let errorMessage = `Upload failed: HTTP ${response.status}`;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMessage = errorJson.error?.message || errorJson.message || errorMessage;
                    } catch (e) {
                        errorMessage = `Upload failed: HTTP ${response.status} - ${errorText}`;
                    }
                    
                    if (window.showUploadError) {
                        window.showUploadError(errorMessage);
                    }
                    
                    throw new Error('Upload failed - see modal for details');
                }
                
                const result = await response.json();
                console.log('Document uploaded with chunking:', result);
                
                // Check for errors in the result
                if (result.success === false) {
                    const errorMessage = result.message || 'Upload failed';
                    console.error('Upload result error:', errorMessage);
                    
                    if (window.showUploadError) {
                        window.showUploadError(errorMessage);
                    }
                    
                    throw new Error('Upload failed - see modal for details');
                }
                
                // Update progress for completion
                if (window.updateUploadProgress) {
                    window.updateUploadProgress('embeddings', 'Document processed and indexed...');
                }
                
                return result;
            } catch (error) {
                console.error('Azure Function upload failed:', error);
                throw error;
            }
        }

        async function uploadDocument(formData) {
            try {
                // Upload directly to n8n webhook (which handles Azure storage and indexing)
                const file = formData.get('file');
                
                // Validate file exists
                if (!file || file.size === 0) {
                    throw new Error('No file selected or file is empty');
                }
                
                console.log('File details:', {
                    name: file.name,
                    type: file.type,
                    size: file.size
                });
                
                // Convert file to base64
                const fileContent = await fileToBase64(file);
                
                // Validate base64 content
                if (!fileContent || fileContent.length === 0) {
                    throw new Error('Failed to convert file to base64');
                }
                
                console.log('Base64 content generated, length:', fileContent.length);
                
                // Calculate file hash for deduplication
                const fileHash = await window.documentEnhancements?.calculateSHA256(file) || null;
                
                // Get the selected department
                const selectedDepartment = formData.get('department');
                console.log('=== DEPARTMENT DEBUG ===');
                console.log('Selected department from form:', selectedDepartment);
                console.log('Department dropdown value:', document.getElementById('department').value);
                console.log('All form data:', {
                    department: formData.get('department'),
                    sopType: formData.get('sopType'),
                    title: formData.get('title')
                });
                
                // Create the payload with both structures for compatibility
                const n8nPayload = {
                    // Flat structure for backward compatibility
                    fileName: file.name,
                    fileContent: fileContent,
                    mimeType: file.type || 'application/octet-stream',
                    department: selectedDepartment || 'General',
                    documentType: formData.get('sopType') || 'SOP',
                    title: formData.get('title') || file.name,
                    description: formData.get('description') || '',
                    keywords: formData.get('keywords') || '',
                    // Nested structure as expected by the n8n workflow
                    file: {
                        name: file.name,
                        type: file.type || 'application/octet-stream',
                        size: file.size,
                        content: fileContent
                    },
                    metadata: {
                        department: selectedDepartment || 'General',
                        documentType: formData.get('sopType'),
                        title: formData.get('title') || file.name,
                        description: formData.get('description') || '',
                        keywords: formData.get('keywords') || '',
                        version: formData.get('version') || '1.0',
                        updateType: formData.get('updateType'),
                        existingDocId: formData.get('existingDocId') || null,
                        uploadedBy: 'SAX Portal User',
                        uploadDate: new Date().toISOString(),
                        source: 'SAX Document Portal',
                        sha256Hash: fileHash,
                        contentHash: fileHash  // Include both for compatibility
                    }
                };
                
                console.log('Uploading document to n8n workflow...');
                console.log('Payload structure:', {
                    hasFile: !!n8nPayload.file,
                    hasFileContent: !!n8nPayload.file.content,
                    fileContentLength: n8nPayload.file.content ? n8nPayload.file.content.length : 0,
                    hasMetadata: !!n8nPayload.metadata
                });
                console.log('=== FULL PAYLOAD DEPARTMENT CHECK ===');
                console.log('Flat department:', n8nPayload.department);
                console.log('Metadata department:', n8nPayload.metadata.department);
                console.log('Full metadata:', n8nPayload.metadata);
                
                const response = await fetch(API_CONFIG.n8n.webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(n8nPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('n8n webhook error response:', errorText);
                    throw new Error(`n8n webhook failed: HTTP ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Document uploaded successfully:', result);
                return result;
            } catch (error) {
                console.error('Upload failed:', error);
                throw error;
            }
        }
        
        async function triggerN8nWorkflow(formData, azureResult) {
            // Convert FormData to JSON for n8n webhook
            const file = formData.get('file');
            const fileContent = await fileToBase64(file);
            
            const selectedDepartment = formData.get('department');
            console.log('triggerN8nWorkflow - Department:', selectedDepartment);
            
            const n8nPayload = {
                file: {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    content: fileContent,
                    contentType: file.type || 'application/octet-stream'
                },
                metadata: {
                    department: selectedDepartment || 'General',
                    documentType: formData.get('sopType'),
                    title: formData.get('title') || file.name,
                    description: formData.get('description') || '',
                    keywords: formData.get('keywords') || '',
                    version: formData.get('version') || '1.0',
                    updateType: formData.get('updateType'),
                    existingDocId: formData.get('existingDocId') || null,
                    uploadedBy: 'SAX Portal User', // You can replace with actual user info
                    uploadDate: new Date().toISOString(),
                    source: 'SAX Document Portal',
                    azureBlobUrl: azureResult.blobUrl || null,
                    azureDocumentId: azureResult.documentId || null
                },
                indexing: {
                    indexName: 'sop-documents',
                    generateEmbeddings: true,
                    extractEntities: true
                }
            };
            
            const n8nResponse = await fetch(API_CONFIG.n8n.webhookUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(n8nPayload)
            });
            
            if (!n8nResponse.ok) {
                throw new Error(`n8n webhook failed: HTTP ${n8nResponse.status}`);
            }
            
            return await n8nResponse.json();
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                // Validate file input
                if (!file) {
                    reject(new Error('No file provided to convert'));
                    return;
                }
                
                if (file.size === 0) {
                    reject(new Error('File is empty'));
                    return;
                }
                
                // Check file size limit (e.g., 10MB)
                const maxSize = 10 * 1024 * 1024; // 10MB in bytes
                if (file.size > maxSize) {
                    reject(new Error(`File size exceeds 10MB limit. File size: ${(file.size / 1024 / 1024).toFixed(2)}MB`));
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = () => {
                    try {
                        const result = reader.result;
                        
                        // Validate result
                        if (!result || typeof result !== 'string') {
                            reject(new Error('Failed to read file content'));
                            return;
                        }
                        
                        // Check if it's a data URL
                        if (!result.includes(',')) {
                            reject(new Error('Invalid data URL format'));
                            return;
                        }
                        
                        // Remove the data:*/*;base64, prefix
                        const base64 = result.split(',')[1];
                        
                        // Validate base64 content
                        if (!base64 || base64.length === 0) {
                            reject(new Error('Failed to extract base64 content'));
                            return;
                        }
                        
                        console.log('Base64 conversion successful:', {
                            originalSize: file.size,
                            base64Length: base64.length,
                            mimeType: file.type
                        });
                        
                        resolve(base64);
                    } catch (error) {
                        reject(new Error(`Base64 conversion error: ${error.message}`));
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('FileReader error:', error);
                    reject(new Error(`Failed to read file: ${error}`));
                };
                
                // Start reading the file
                try {
                    reader.readAsDataURL(file);
                } catch (error) {
                    reject(new Error(`Failed to start reading file: ${error.message}`));
                }
            });
        }

        function handleUploadError(error) {
            // Show upload modal
            showUploadModal();
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Uploading...';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            
            alert(`Upload failed: ${error.message}\n\nPlease try again or contact IT support if the problem persists.`);
        }

        function validateForm() {
            const dept = departmentSelect.value;
            const sopType = sopTypeSelect.value;
            const updateType = updateTypeSelect.value;
            const file = fileInput.files[0];

            // Check file first with better UX
            if (!file) {
                alert('Please select a file to upload.');
                fileUploadArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Highlight the upload area briefly
                fileUploadArea.style.border = '2px solid #dc2626';
                setTimeout(() => {
                    fileUploadArea.style.border = '';
                }, 2000);
                return false;
            }

            if (!dept) {
                alert('Please select a department.');
                departmentSelect.focus();
                return false;
            }

            if (!sopType) {
                alert('Please select a document type.');
                sopTypeSelect.focus();
                return false;
            }

            if (!updateType) {
                alert('Please select an action type (New Document or Update Existing).');
                updateTypeSelect.focus();
                return false;
            }

            if (updateType === 'update' && !selectedSOPIdInput.value) {
                alert('Please select an existing document to update.');
                existingSOPsDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
                return false;
            }

            if (updateType === 'new' && !document.getElementById('sopTitle').value.trim()) {
                alert('Please provide a title for the new document.');
                document.getElementById('sopTitle').focus();
                return false;
            }

            return true;
        }

        // Authentication helper functions - implement based on your Azure AD setup
        async function getAccessToken() {
            // Implement your Azure AD authentication logic here
            // This could use MSAL.js or your existing authentication system
            // return await msalInstance.acquireTokenSilent({...});
            throw new Error('Authentication not implemented - configure Azure AD integration');
        }

        // Utility function to get file extension icon
        function getFileTypeClass(filename) {
            const extension = filename.split('.').pop().toLowerCase();
            switch (extension) {
                case 'pdf': return 'pdf';
                case 'docx': 
                case 'doc': return 'docx';
                case 'xlsx':
                case 'xls': return 'xlsx';
                case 'txt': return 'txt';
                default: return 'pdf';
            }
        }

        function completeUpload() {
            submitBtn.style.display = 'none';
            progressBar.style.display = 'none';
            progressFill.style.width = '100%';
            successMessage.style.display = 'block';
            
            setTimeout(() => {
                form.reset();
                selectedFileDiv.style.display = 'none';
                fileUploadArea.style.display = 'block';
                existingSOPsDiv.classList.add('hidden');
                additionalInfoDiv.style.display = 'none';
                successMessage.style.display = 'none';
                submitBtn.style.display = 'block';
                submitBtn.disabled = false;
                submitBtn.textContent = 'Upload Document';
                progressFill.style.width = '0%';
            }, 3000);
        }
        
        // Admin console password protection
        function openAdminConsole() {
            const password = prompt('Enter admin password to access the console:');
            if (password === 'SAXAdmin2024') {
                window.location.href = 'admin.html';
            } else if (password !== null) {
                alert('Incorrect password. Access denied.');
            }
        }
    </script>
    <!-- Document Preview Module -->
    <script src="js/document-preview.js"></script>
    <!-- Document Enhancements Module -->
    <script src="js/document-enhancements.js"></script>
    <script>
        // Initialize document enhancements after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            if (!window.documentEnhancements) {
                window.documentEnhancements = new DocumentEnhancements();
                window.documentEnhancements.loadSavedDepartments();
                window.documentEnhancements.addDepartmentFilter();
            }
        });
    </script>
</body>
</html>
